<job>
<script language="JScript">//<!-- GlobalCode LeadingTag -->
//---------------------------------------------------------------------
// Â© Oleg Kulikov, sysprg@live.ru
//---------------------------------------------------------------------
// Project: EnumDevicesAndVolumes
// Version: 1.0
// FileId:  f:\Delme\CleanBCD\EnumDevicesAndVolumes
// When:    26 Jun 2015,  Friday,  08:02:00
// Who:     Oleg Kulikov, sysprg@live.ru
//---------------------------------------------------------------------
// This head was generated by PROFILE.THE code of the THE.EXE
//---------------------------------------------------------------------
// This is REDESIGN of the project EnumDevicesPartionsVolumesClass
// and thus it keeps most part of that project code. Versioning of
// this project continues versioning of the previous one.
//---------------------------------------------------------------------
// EnumDevicesAndVolumes - is a name of the WSF-file but the name
// of the Class which code it contains, is EnumDevicesVolumesClass
//---------------------------------------------------------------------
// Project: EnumDevicesPartionsVolumesClass
// Version: 1.0
// FileId:  f:\Delme\CleanBCD\EnumDevicesPartionsVolumesClass.wsf
// When:    19 Jun 2015,  Friday,  11:44:02
// Who:     Oleg Kulikov, sysprg@live.ru
//---------------------------------------------------------------------
// This head was generated by PROFILE.THE code of the THE.EXE
//---------------------------------------------------------------------
// History of the project code:
// Partitions enumeration was started at 22.04.2015 in msft_disk.js and
// then was used in 149 files kept in f:\Delme\CleanBCD\archive.
// This gives "149" as a starting build number for the following
// partitions enumeration code.
//---------------------------------------------------------------------
// Volumes enumeration with Win32_Logical was started at 01.05.2015 in
// get-parts-info.js and continued in 59 files kept in
// f:\Delme\CleanBCD\archive.
// This gives "59" as a current build number for the following
// partitions enumeration code.
//---------------------------------------------------------------------

// June 23, implemented in all of the code.
function GlobalBuffers()
{
   var IMess = [];
   var EMess = [];

   this.Out = {};
   this.Out.StdErr = WScript.StdErr;
   this.Out.StdOut = WScript.StdOut;

   this.PutIMsg = function( msg )
   {
      IMess[ IMess.length ] = msg;
      return false;
   }
   this.PutEMsg = function( msg )
   {
      PMess[ EMess.length ] = msg;
      return false;
   }
   this.UnloadBuffers = function( )
   {
      for ( var i = 0; i < EMess.length; i++ )
      {
         this.Out.StdErr.WriteLine( EMess[ i ] );
      }
      EMess = [];
      for ( var i = 0; i < IMess.length; i++ )
      {
         this.Out.StdOut.WriteLine( IMess[ i ] );
      }
      PMess = [];
   }
}

String.prototype.startsWith = function( str )
{
   return ( this.substr( 0, str.length ).toLowerCase() == str.toLowerCase() );
}

var CurrentUserSID       = '';
var CurrentUserObject    = {}; // June 26
var CurrentVersionObject = {}; // June 26

// GetCurrentUserSID function
// Is called from StdRegWrapperClass constructor
// Returns SID for the last logged user
// Final fix: June 25, June 26 - eliminated,
// replaced by the code at the bottom of this
// class code which builds objects

</script>                    <!-- GlobalCode         TraingTag  -->
<script language="JScript">//<!-- StdRegWrapperClass LeadingTag -->
/////////////////////////////////////////////////////////////////////////////////////
//                    StdRegWrapperClass( ServerName )                             //
/////////////////////////////////////////////////////////////////////////////////////
// This class presents methods which permit easily read Registry data from JS.     //
// It encapsulates WMI class StdRegProv methods to get and convert necessary data. //
// See reference of the WMI class StdRegProv at:                                   //
// https://msdn.microsoft.com/en-us/library/aa393664(v=vs.85).aspx - reference     //
/////////////////////////////////////////////////////////////////////////////////////
// This class exports wrapper class methods for likewise StdRegProv methods:       //                                                             //                                                             //
// RegEnumSubKey(    root, regPath )                                               //
// RegEnumValues(    root, regPath )                                               //
// RegCheckAccess(   root, regPath )                                               //
// RegGetDWORDValue(          root, regPath, valueName )                           //
// RegGetQWORDValue(          root, regPath, valueName )                           //
// RegGetBinaryValue(         root, regPath, valueName )                           //
// RegGetStringValue(         root, regPath, valueName )                           //
// RegGetMultiStringValue(    root, regPath, valueName )                           //
// RegGetExpandedStringValue( root, regPath, valueName )                           //
//---------------------------------------------------------------------------------//
// This class exports it's own methods based on the methods listed above:          //                                                   //
// RegGetValue(     root, regPath, valueObj  )                                     //
// RegGetAllValues( root, regPath ) => { name: vName, type: vType, value: vValue } //
//---------------------------------------------------------------------------------//
// This class exports it's own methods:                                            //
// RegDateToDate( dword )                                                          //
// SetServer = function( name )                                                    //
// SetWarnings = function( level )                                                 //
// SetUseCallCounts( level )                                                       //
// GetCallCounts()                                                                 //
// GetVersion()                                                                    //
/////////////////////////////////////////////////////////////////////////////////////
// Function RunRegMethod( methodname, root, regPath, valueName ) is used to run any//
// of the incapsulated StdRegProv methods.                                         //
/////////////////////////////////////////////////////////////////////////////////////
function StdRegWrapperClass( ServerName )
{
/*
--------------------------------------------------------------------------------------
RegRead 1-st was used in BCDS-FromReg01.js at 11.04.2015 and then was referenced in 92
files in f:\Delme\CleanBCD\archive
WbemScripting.SWbemLocator 1-st was used in BCDS-FromReg01.js at 11.04.2015 and then
was referenced in 154 files in f:\Delme\CleanBCD\archive
Thus:
version 01 continued from 01.00 till 01.091
version 02 continued from 02.00 till 02.154 at June 18 2015
--------------------------------------------------------------------------------------
"02.154 June 18 2015" - call of GetCurrentUserSID( regObj ) was implemented into
                        constructor as no one method of this class can be run untill
                        constructor finished, June 19, version number incremented.
"02.155 June 19 2015"   Output bufferization can be enabled by the caller, June 23
"02.156 June 23 2015"   Method RegGetEnumValues implemented at July 27
"02.157 Julye 27 2015"  parseInt( CurrentVersionObject.CurrentBuild ) implemented at July 28
*/
   this.OutBuffers = null; // June 23, implemented

   this.Out = {};
   this.Out.StdErr = WScript.StdErr;
   this.Out.StdOut = WScript.StdOut;

   if ( typeof( ServerName ) == "undefined" )
   {
      ServerName = "."; // local machine
   }

   var Version = "02.158 July 28 2015";

   this.GetVersion = function()
   {
      return Version;
   }

   var IgnoreWarnings = true;    // can be changed by the caller
   var UseCallCounts  = false;   // can be changed by the caller

   var Usage = {
                  "RegEnumSubKey": 0,
                  "RegEnumValues": 0,
                  "RegCheckAccess": 0,
                  "RegGetDWORDValue": 0,
                  "RegGetQWORDValue": 0,
                  "RegGetBinaryValue": 0,
                  "RegGetStringValue": 0,
                  "RegGetMultiStringValue": 0,
                  "RegGetExpandedStringValue": 0
               };

   var HKCR = 0x80000000;// HKEY_CLASSES_ROOT
   var HKCU = 0x80000001;// HKEY_CURRENT_USER
   var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE
   var HKU  = 0x80000003;// HKEY_USERS
   var HKCC = 0x80000005;// HKEY_CURRENT_CONFIG

   //
   // service objects required for all methods in the class
   //
   var objLocator  = new ActiveXObject( "WbemScripting.SWbemLocator" );
   var objService  = objLocator.ConnectServer( ServerName, "root\\default" );
   var objReg      = objService.Get( "StdRegProv" );
   var objMethod   = null;
   var objInParam  = null;
   var objOutParam = null;

   //
   // this method returns Version of this class.
   //
   this.GetVersion = function()
   {
      return Version;
   }

   //
   // this method returns object of StdRegProv class.
   //
   this.GetStdRegProvService = function()
   {
      return objReg;
   }

   //
   // this method sets name of the network server.
   //
   this.SetServer = function( name )
   {
      if ( typeof( name ) == "string" )
      {
         ServerName = name;
         objService  = objLocator.ConnectServer( ServerName, "root\\default" );
      }

      return ( ServerName == name );
   }

   //
   // this method sets value of the IgnoreWarings flag.
   // Caller could disable or enable output of the warning
   // messages as soon as an instance of the StdRegWrapperClass
   // was created by running this method.
   //
   this.SetWarnings = function( level )
   {
      if ( typeof( level ) == "undefined" )
      {
         IgnoreWarnings = false;
      }
      else
      {
         IgnoreWarnings = level ? false : true;
      }

      return IgnoreWarnings;
   }

   //
   // this method sets value of the UseCallCounts flag.
   // Caller could disable or enable support of the
   // counters for each of the methods called
   //
   this.SetUseCallCounts = function( level )
   {
      if ( typeof( level ) == "undefined" )
      {
         UseCallCounts = true;
      }
      else
      {
         UseCallCounts = level ? true : false;
      }
      if ( UseCallCounts )
      {
         for ( var p in Usage )
         {
            Usage[ p ] = 0;
         }
      }
      return UseCallCounts;
   }

   //
   // this method returns Usage object.
   //
   this.GetCallCounts = function()
   {
      return Usage;
   }

   //
   // Function to parse and verify input parameters, set correct
   // properties for the objInParam and run StdRegProv method.
   // Output parameters are then analysed and a warning message
   // is issued on StdErr provided warnings flag permits warnings.
   // This is an ENGINE of the StdRegWrapperClass.
   //
   function RunRegMethod( methodname, root, regPath, valueName )
   {
      //
      // output parameters lists for each method of the class
      //
      var methodsParams = {
         "CheckAccess":            "bGranted",
         "EnumKey":                "sNames",
         "EnumValues":             "sNames,Types", // Types: int32 array
         "GetStringValue":         "sValue",
         "GetExpandedStringValue": "sValue",
         "GetMultiStringValue":    "sValue",
         "GetDWORDValue":          "uValue",
         "GetQWORDValue":          "uValue",
         "GetBinaryValue":         "uValue"
      };

      var msg = "";

      if ( typeof( methodname ) != "string"  )
      {
         WScript.StdErr.WriteLine( "*** inavalid methodname " );
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }
      if ( typeof( regPath ) != "string" || regPath.indexOf( "\\" ) == - 1 )
      {
         WScript.StdErr.WriteLine( "*** Method " + RegMethod + " incorrect regPath=" + regPath );
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }

      var RegMethod = "Reg" + methodname;

      if ( typeof( methodsParams[ methodname ] ) == "undefined" ) // verify that a correct
      {                                                           // method name is given
         msg = "*** Method " + RegMethod + " is absent in StdRegWrapperClass";
      }

      if ( typeof( root ) != "number" || root < HKCR || root > HKCC )
      {
         msg = "*** Invalid root is given for the method " + RegMethod;
      }

      var IsValueName = ( typeof( valueName ) == "string" );

      if ( methodname.substr( 0, 3 ) == "Get" && ! IsValueName )
      {
         msg = "*** Parameter valuename is required for the method " + RegMethod;
      }

      if ( msg.length )
      {
         Out.StdErr.WriteLine( msg );
         if ( msg.indexOf( "valuename"    ) > - 1
         ||   msg.indexOf( "Invalid root" ) > - 1 )
         {
            Out.StdErr.WriteLine( "RegMethod " + RegMethod );
            Out.StdErr.WriteLine( "root "      + root      );
            Out.StdErr.WriteLine( "regPath "   + regPath   );
            Out.StdErr.WriteLine( "valuename " + typeof( valuename ) );
         }
         WScript.Quit();//**********************QUIT FROM StdReg*********************************
      }

      if ( UseCallCounts ) // if caller have requested
      {
         Usage[ RegMethod ]++;
      }

      objMethod   = objReg.Methods_.Item( methodname );
      objInParam  = objMethod.InParameters.SpawnInstance_();
      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;

      if ( IsValueName )
      {
         objInParam.sValueName = valueName;
      }

      if ( ( methodsParams[ methodname ] == "bGranted" ) )
      {  // for property subpath objOutParam.ReturnValue = 2 regrdless 1 or 9
         objInParam.uRequired = 9;// KEY_QUERY_VALUE + KEY_ENUMERATE_SUB_KEYS
      }

      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam ); // run StdRegProv method

      var res = null;

      if ( objOutParam.ReturnValue != 0 )
      {
         if ( IgnoreWarnings ) return res;

         var msg = "*** StdRegProv method " + RegMethod  +
         " ReturnValue = " + objOutParam.ReturnValue + " for the path " + regPath;

         if ( IsValueName )
         {
             msg  += ", value name = " +
             ( typeof( valueName ) == "undefined" ? "undefined" : valueName );
         }
         Out.StdErr.WriteLine( msg );
         return res;
      }

      //
      // for Get-methods we return value which name
      // is given by methodsParams[ methodname ]
      //
      if ( methodname.startsWith( "Get" ) )
      {
         return objOutParam[ methodsParams[ methodname ] ];
      }

      //
      // for enum-methods we always return an array
      //
      var outParams = methodsParams[ methodname ].split( "," );

      res = {};

      for ( var i = 0; i < outParams.length; i++ )
      {
         res[ outParams[ i ] ] = objOutParam[ outParams[ i ] ];
      }

      return res;

   }// End-of-RunRegMethod function

   var InterpreteRegValueType = {
       0: "REG_NONE",                       // No value type
       1: "REG_SZ",                         // Unicode nul terminated string
       2: "REG_EXPAND_SZ",                  // Unicode nul terminated string
                                            //    (with environment variable references)
       3: "REG_BINARY",                     // Free form binary
       4: "REG_DWORD",                      // 32-bit number
       5: "REG_DWORD_BIG_ENDIAN",           // 32-bit number
       6: "REG_LINK",                       // Symbolic Link (unicode)
       7: "REG_MULTI_SZ",                   // Multiple Unicode strings
       8: "REG_RESOURCE_LIST",              // Resource list in the resource map
       9: "REG_FULL_RESOURCE_DESCRIPTOR",   // Resource list in the hardware description
      10: "REG_RESOURCE_REQUIREMENTS_LIST", //
      11: "REG_QWORD"                       // 64-bit number
   };

   //
   // Predefined Value Types from WinNT.h
   //

   var REG_NONE                       =  0; // No value type
   var REG_SZ                         =  1; // Unicode nul terminated string
   var REG_EXPAND_SZ                  =  2; // Unicode nul terminated string
                                            // (with environment variable references)
   var REG_BINARY                     =  3; // Free form binary
   var REG_DWORD                      =  4; // 32-bit number
   var REG_DWORD_BIG_ENDIAN           =  5; // 32-bit number
   var REG_LINK                       =  6; // Symbolic Link (unicode)
   var REG_MULTI_SZ                   =  7; // Multiple Unicode strings
   var REG_RESOURCE_LIST              =  8; // Resource list in the resource map
   var REG_FULL_RESOURCE_DESCRIPTOR   =  9; // Resource list in the hardware description
   var REG_RESOURCE_REQUIREMENTS_LIST = 10; //
   var REG_QWORD                      = 11; // 64-bit number


   //
   // Receives: Array of uint8
   // Returns:  Heximal string or array of strings joined by ","
   //
   function RegBinaryToHexString( binVal )
   {
      function Byte2Hex( b )
      {
         var bhex = b.toString( 16 );
         if ( bhex.length < 2 ) bhex = "0" + bhex;
         return bhex;
      }
      function Uint8ArrayToHexString( vals )
      {
         var tmp = "";

         for ( var i = 0; i < vals.length; i++)
         {
            tmp += Byte2Hex( vals[ i ] );
         }
         return tmp;
      }
      return Uint8ArrayToHexString( binVal );
   }

   /*
   -------------------------------------------------------------------------------------------------
      uint32 CheckAccess(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           uint32 uRequired = 3,
      [out]          bool bGranted
      );
   -------------------------------------------------------------------------------------------------
   KEY_QUERY_VALUE,         1 (0x1), Required to query the values of a registry key.
   KEY_SET_VALUE,           2 (0x2), Required to create, delete, or set a registry value.
   KEY_CREATE_SUB_KEY,      4 (0x4), Required to create a subkey of a registry key.
   KEY_ENUMERATE_SUB_KEYS,  8 (0x8), Required to enumerate the subkeys of a registry key.
   KEY_NOTIFY,            16 (0x10), Required to request change notifications for a registry
                                     key or for subkeys of a registry key.
   KEY_CREATE,           32 (0x20),  Required to create a registry key.
   DELETE,          65536 (0x10000), Required to delete a registry key.
   READ_CONTROL,   131072 (0x20000), Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE,
                                     KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY values.
   WRITE_DAC,      262144 (0x40000), Required to modify the DACL in the object's security descriptor.
   WRITE_OWNER,    524288 (0x80000), Required to change the owner in the object's security descriptor.
   -------------------------------------------------------------------------------------------------
   KEY_QUERY_VALUE | KEY_SET_VALUE, 3, Default value, allows querying, creating,
                                       deleting, or setting a registry value.
   -------------------------------------------------------------------------------------------------
   */
   this.RegCheckAccess = function( root, regPath )
   {
      return RunRegMethod( "CheckAccess", root, regPath );
   }

   /*
   --------------------------------------------------------------------------
   uint32 GetSecurityDescriptor(
      [in]  uint32               hDefKey = HKEY_LOCAL_MACHINE,
      [in]  string               sSubKeyName,
      [out] __SecurityDescriptor Descriptor
   );
   --------------------------------------------------------------------------
   */
   this.RegGetSecurityDescriptor = function( root, regPath )
   {
      objMethod  = objReg.Methods_.Item( "GetSecurityDescriptor" );
      objInParam = objMethod.InParameters.SpawnInstance_();

      objInParam.hDefKey     = root;
      objInParam.sSubKeyName = regPath;

      objOutParam = objReg.ExecMethod_( objMethod.name, objInParam );
      // and now I had to serialize __SecurityDescriptor structure
      // and return it to caller. Other way: convert structure
      // received into format clear to caller.
   }// End-of-RegGetSecurityDescriptor

   /*
   --------------------------------------------------------
   uint32 EnumKey(
       [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
       [in]           string sSubKeyName,
       [out]          string sNames[]
   );
   --------------------------------------------------------
   */
   this.RegEnumKey = function( root, regPath )
   {
      var res = RunRegMethod( "EnumKey", root, regPath );
      if ( res == null
      ||   res.sNames == null
      ||   typeof( res.sNames ) == "undefined"  ) return [];
      return res.sNames.toArray();
   }

   /*
   --------------------------------------------------------
   uint32 EnumValues(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [out]          string sNames[],
      [out]          sint32 Types[]
   );
   --------------------------------------------------------
   */
   this.RegEnumValues = function ( root, regPath )
   {
      var res = RunRegMethod( "EnumValues", root, regPath );
      if ( res == null ) return res;
      var names = res.sNames.toArray();
      var types = res.Types.toArray();
      var ret   = [];

      for ( var i = 0; i < types.length; i++ )
      {
         ret[ i ] = { "name": names[ i ], "type": types[ i ] };
      }

      return ret;
   }

   /*
   --------------------------------------------------------------
   uint32 GetBinaryValue(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           string sValueName,
      [out]          uint8  uValue[]
   );
   ---------------------------------------------------------------
   */
   this.RegGetBinaryValue = function ( root, regPath, valueName )
   {
      var res = RunRegMethod( "GetBinaryValue", root, regPath, valueName );
      if ( res == null ) return res;
      return RegBinaryToHexString( VBArray( res ).toArray() );
   }

   /*
   ---------------------------------------------------------------
   uint32 GetStringValue(
     [in]  uint32 hDefKey = HKEY_LOCAL_MACHINE,
           string sSubKeyName,
           string sValueName,
     [out] string sValue
   );
   ---------------------------------------------------------------
   */
   this.RegGetStringValue = function ( root, regPath, valueName )
   {
      return RunRegMethod( "GetStringValue", root, regPath, valueName );
   }

   /*
   -----------------------------------------------------------------------
   uint32 GetExpandedStringValue(
     [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in]           string sSubKeyName,
     [in]           string sValueName,
     [out]          string sValue
    );
   -----------------------------------------------------------------------
   */
   this.RegGetExpandedStringValue = function ( root, regPath, valueName )
   {
      return RunRegMethod( "GetExpandedStringValue", root, regPath, valueName );
   }

   /*
   --------------------------------------------------------------
   uint32 GetDWORDValue(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           string sValueName,
      [out]          uint32 uValue
   );
   --------------------------------------------------------------
   */
   this.RegGetDWORDValue = function ( root, regPath, valueName )
   {
      return RunRegMethod( "GetDWORDValue", root, regPath, valueName );
   }

   /*
   --------------------------------------------------------------
   uint32 GetQWORDValue(
      [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
      [in]           string sSubKeyName,
      [in]           string sValueName,
      [out]          uint64 uValue
   );
   --------------------------------------------------------------
   */
   this.RegGetQWORDValue = function ( root, regPath, valueName )
   {
      return RunRegMethod( "GetQWORDValue", root, regPath, valueName );
   }

   /*
   -----------------------------------------------------------------
   uint32 GetMultiStringValue(
     [in, optional] uint32 hDefKey = HKEY_LOCAL_MACHINE,
     [in]           string sSubKeyName,
     [in]           string sValueName,
     [out]          string sValue[]
   );
   -----------------------------------------------------------------
   */
   this.RegGetMultiStringValue = function( root, regPath, valueName )
   {
      var res = RunRegMethod( "GetMultiStringValue", root, regPath, valueName );
      return res.toArray().join( "," );
   }

   /*
   ---------------------------------------------------------
   RegGetValue(
      [in] { "name:" vName, "type": vType }
   );
   [out] - depends on the type of the value with given name
   ---------------------------------------------------------
   */
   this.RegGetValue = function( root, regPath, valueObj )
   {
      var name = valueObj.name;
      var type = valueObj.type, val = null;
      switch( type )
      {
         case REG_SZ:       { val = this.RegGetStringValue(         root, regPath, name ); break; }
         case REG_EXPAND_SZ:{ val = this.RegGetExpandedStringValue( root, regPath, name ); break; }
         case REG_MULTI_SZ: { val = this.RegGetMultiStringValue(    root, regPath, name ); break; }
         case REG_BINARY:   { val = this.RegGetBinaryValue(         root, regPath, name ); break; }
         case REG_DWORD:    { val = this.RegGetDWORDValue(          root, regPath, name ); break; }
         case REG_QWORD:    { val = this.RegGetQWORDValue(          root, regPath, name ); break; }
         case REG_FULL_RESOURCE_DESCRIPTOR: { val = this.RegGetBinaryValue( root, regPath, name ); break; }
      }

      return { "name": name, "type": InterpreteRegValueType[ type ], "value": val };
   }

   /*
   ----------------------------------------------------------------------
   RegGetAllValues( root, regPath )
   returns an array of objects { "name": vName, "value": vValue }
   ----------------------------------------------------------------------
   */
   this.RegGetAllValues = function( root, regPath )
   {
      var valuesObj = this.RegEnumValues( root, regPath );
      if ( ! valuesObj || ! valuesObj.length ) return [];
      var res = [];

      for ( var i = 0; i < valuesObj.length; i++ )
      {
         res[ i ] = this.RegGetValue( root, regPath, valuesObj[ i ] );
      }
      return res;
   }

   /*
   ----------------------------------------------------------------------
   RegGetEnumValues( root, regPath )
   Special case of the RegGetAllValues( root, regPath ) which reads
   all values of Enumeration of the objects. In this case REG_DWORD
   with a name Count is read at first and then in the loop [0-Count-1]
   RegSZ values with a names i.toString() are read one by one and
   values are placed into an output array. If the value read conrains
   "" than such a value is not placed into the output array. Likewise
   values are present in enumerations of the objects in Windows 9600-.
   ----------------------------------------------------------------------
   */
   this.RegGetEnumValues = function( root, regPath, flag )
   {
      var Count = this.RegGetDWORDValue( root, regPath, "Count" );
      if ( typeof( flag ) == "undefined" )
      {
         flag = false;
      }

      var res = [], val;

      for ( var i = 0; i < Count; i++ )
      {
         val = this.RegGetStringValue( root, regPath, i.toString() );

         if ( ! flag )
         {
            if ( val.indexOf( "LEGACY_" ) > - 1 ) continue;
         }
         res[ res.length ] = val;
      }
      return res;
   }
   //
   // this method converts registry REG_DWORD date to
   // standard JS Date object and returns it.
   //
   this.RegDateToDate = function( regDate )
   {
      var MaxDWORD = 0x100000000, jsDate;

      if ( regDate < MaxDWORD )
      {
         jsDate = new Date( 1000 * regDate );
      }
      else
      {
         var tmp3 = 10 * (( regDate / 1000000 ).toFixed());
         jsDate = new Date( tmp3 );
//Out.StdOut.WriteLine( "Final: " + " " + jsDate.toString() + " input=" + regDate + " for conversion: " + tmp3 );
/*
------------------------------------------------------------------------------------------------
var tmp3 = 1000*(( regDate / 1000000 ).toFixed());
Final:  Fri Jun 10 03:55:02 UTC+0300 6112 input=130722771301508910 for conversion: 130722771302000
Final:  Sat Mar 31 15:16:18 UTC+0300 6114 input=130779749777690889 for conversion: 130779749778000
Final:  Sat Mar 31 15:16:46 UTC+0300 6114 input=130779749806453223 for conversion: 130779749806000
Final:  Fri Jun 10 03:55:03 UTC+0300 6112 input=130722771302765282 for conversion: 130722771303000
------------------------------------------------------------------------------------------------
         var tmp1 = ( regDate % MaxDWORD );// seconds
         var tmp2 = ( ( ( tmp1 % MaxDWORD ).toFixed() ) % 1000 );
         var tmp3 = 1000 * ( 1000 * tmp2 + tmp1 );
Final:  Sat Sep 15 22:36:16 UTC+0300 2103 input=130722771301508910 for conversion: 4219328176000
Final:  Wed Mar 27 04:02:08 UTC+0300 2013 input=130779749777690889 for conversion: 1364346128000
Final:  Wed Feb 26 18:27:28 UTC+0300 2014 input=130779749806453223 for conversion: 1393428448000
Final:  Thu Oct  4 17:49:04 UTC+0300 2103 input=130722771302765282 for conversion: 4220952544000
------------------------------------------------------------------------------------------------
         var tmp1 = ( regDate % MaxDWORD );// seconds
         var tmp2 = ( ( ( regDate % MaxDWORD ).toFixed() ) % 1000 );
         var tmp3 = 1000 * ( 1000 * tmp2 + tmp1 );
Final:  Sat Sep 15 22:36:16 UTC+0300 2103 input=130722771301508910 for conversion: 4219328176000
Final:  Wed Mar 27 04:02:08 UTC+0300 2013 input=130779749777690889 for conversion: 1364346128000
Final:  Wed Feb 26 18:27:28 UTC+0300 2014 input=130779749806453223 for conversion: 1393428448000
Final:  Thu Oct  4 17:49:04 UTC+0300 2103 input=130722771302765282 for conversion: 4220952544000
------------------------------------------------------------------------------------------------
         var tmp1 = ( regDate % MaxDWORD );// seconds
         var tmp2 = ( ( ( regDate / MaxDWORD ).toFixed() ) % 1000 );
         var tmp3 = 1000 * ( 1000 * tmp2 + tmp1 );
Final:  Sun Sep 16 23:52:56 UTC+0300 2103 input=130722771301508910 for conversion: 4219419176000
Final:  Sun Mar 31 20:32:08 UTC+0300 2013 input=130779749777690889 for conversion: 1364751128000
Final:  Thu Feb 27 18:04:08 UTC+0300 2014 input=130779749806453223 for conversion: 1393513448000
Final:  Mon Oct  1 12:52:24 UTC+0300 2103 input=130722771302765282 for conversion: 4220675544000
------------------------------------------------------------------------------------------------
*/
      }
      return jsDate;
   }
/*
   this.RegDateToDateString = function( regDate )
   {
      return this.RegDateToDate( regDate ).toString();
   }
*/

   //-----------------------------------------------------------------------------
   // the only useful actions of the class constructor, tested at June 26, WAD
   //-----------------------------------------------------------------------------

   var MSSoft             = "SOFTWARE\\Microsoft\\";
   var CurrentVersionPath = MSSoft + "Windows NT\\CurrentVersion";
   var currentusername = this.RegGetStringValue( HKLM,
                         MSSoft + "Windows\\CurrentVersion\\Authentication\\LogonUI",
                         "LastLoggedOnUser" );

   //value looks like: ".\\sysprg".split( "\\" ) ==> { server, username };

   var tmp = currentusername.split( "\\" );
   var unamechunk = tmp[ 1 ].substr( 0, 5 ) + "_"; // Windows 10 shortens usernames till 5 characters

   CurrentUserObject[ "CurrentServer"   ] = tmp[ 0 ];
   CurrentUserObject[ "CurrentUserName" ] = tmp[ 1 ];

   currentusername = tmp[ 1 ];

   // SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList

   var proot = CurrentVersionPath + "\\ProfileList";
   var profiles = this.RegEnumKey( HKLM, proot );
   var puname;

   for ( var i = 0; i < profiles.length; i++ )
   {
      var userprof = this.RegGetStringValue( HKLM, proot + "\\" + profiles[ i ], "ProfileImagePath" );
      puname = userprof.split( "\\" )[ userprof.split( "\\" ).length - 1 ];

      if ( currentusername == puname         // Windows7/8, local user
      ||   puname.startsWith( unamechunk ) ) // Windows 10, MS-username
      {
         CurrentUserObject[ "CurrentUserProfile" ] = userprof;
         CurrentUserObject[ "CurrentUserSID"     ] = profiles[ i ];
         CurrentUserSID = profiles[ i ];
      }
   }

   delete unamechunk, currentusername, proot, profiles, puname;

   tmp = this.RegGetAllValues( HKLM, CurrentVersionPath );

   //
   // for each Windows version, following keys always will
   // be present in the CurrentVersionObject:
   //
   // "ProductName"="Microsoft Windows XP", "CurrentBuildNumber"="2600",
   // "BuildLab"="2600.xpsp_sp3_qfe.150205-1510",
   //
   // "ProductName"="Windows 7 Enterprise", "CurrentBuildNumber"="7601",
   // "BuildLab"="7601.win7sp1_gdr.150427-0707",
   //
   // "ProductName"="Windows 8.1 Pro", "CurrentBuildNumber"="9600",
   // "BuildLab"="9600.winblue_r9.150322-1500",
   //
   // "ProductName"="Windows 10 Pro Insider Preview", "CurrentBuildNumber"="10130",
   // "BuildLab"="10130.fbl_impressive.150522-2224"
   //
   // CurrentVersionObject.CurrentBuildNumber
   //
   for( var i = 0; i < tmp.length; i++  )
   {
      CurrentVersionObject[ tmp[ i ].name ] =  tmp[ i ].value;
   }
   tmp = parseInt( CurrentVersionObject.CurrentBuild );
   CurrentVersionObject.CurrentBuild = tmp;
   Out.StdOut.WriteLine( '\n' );
   delete tmp, MSSoft, CurrentVersionPath;

} // End-of-StdRegWrapperClass()

</script>                    <!-- StdRegWrapperClass TrailingTag -->
<script language="JScript">//<!-- CollectionClass LeadingTag  -->

//
// CollectionClass prototypes
//

String.prototype.HexString2ASCI = function()
{
   var tmp = this.split( "00" ).join( "" );
   var str = "";
   while ( tmp.length > 0 )
   {
      str += String.fromCharCode( parseInt( tmp.substr( 0, 2 ), 16 ) );
      tmp = tmp.substr( 2 );
   }
   return str;
}
   if ( typeof( repeat ) == "undefined" )
   {
      String.prototype.repeat = function( n )
      {
         var tmp = this;
         if ( tmp.length == n ) return tmp;
         while( tmp.length < n ) tmp += this;
         return tmp;
      }
   }
   String.prototype.left = function( n, char )
   {
      if ( typeof( char ) == "undefined" ) char = " ";
      if ( this.length >= n ) return this.substr( 0, n );
      if ( this.length == n ) return this;
      return this + char.repeat( n - this.length );
   }
   String.prototype.right = function( n, char )
   {
      if ( typeof( char ) == "undefined" ) char = " ";
      if ( this.length > n ) return this.substr( this.length - n );
      if ( this.length == n ) return this;
      return char.repeat( n - this.length ) + this;
   }
var PartitionsGuids = {
   "{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}": "EFI System Partition",
   "{e3c9e316-0b5c-4db8-817d-f92df00215ae}": "Microsoft Reserved Partition",
   "{de94bba4-06d1-4d40-a16a-bfd50179d6ac}": "Microsoft Recovery Partition",
   "{ebd0a0a2-b9e5-4433-87c0-68b6b72699c7}": "PARTITION BASIC DATA",
   "{af9b60a0-1431-4f62-bc68-3311714a69ad}": "MBR partition 0x42",
   "{5808c8aa-7e8f-42e0-85d2-e1e90434cfb3}": "partition for dynamic config DB",
   "{eec5ad98-8080-425f-922a-dabf3de3f69a}": "SD-cards including those in the mobile phones"
};

// https://msdn.microsoft.com/en-us/library/aa390788(v=vs.85).aspx - StdReg ref
var ClassGUIDs = { // add this object into
   "{53f56307-b6bf-11d0-94f2-00a0c91efb8b}": "GUID_DEVINTERFACE_DISK",
   "{53f56308-b6bf-11d0-94f2-00a0c91efb8b}": "GUID_DEVINTERFACE_CDROM",
   "{53f5630b-b6bf-11d0-94f2-00a0c91efb8b}": "GUID_DEVINTERFACE_TAPE",
   "{53f5630c-b6bf-11d0-94f2-00a0c91efb8b}": "GUID_DEVINTERFACE_WRITEONCEDISK",
   "{53f5630a-b6bf-11d0-94f2-00a0c91efb8b}": "GUID_DEVINTERFACE_PARTITION",
   "{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}": [ "GUID_DEVINTERFACE_VOLUME","MOUNTDEV_MOUNTED_DEVICE_GUID"],
   "{2accfe60-c130-11d2-b082-00a0c91efb8b}": "GUID_DEVINTERFACE_STORAGEPORT"
};

var MbrTypeExplain = {
    1: "FAT12",
    4: "FAT16",
    5: "Extended",
    6: "HUGE",
    7: "NTFS/ExFAT",
   12: "FAT32",
   15: "Extended"
};

function ExplainDriveType( p, v )
{
   if ( p != "DriveType" ) return v;
   switch( v )
   {
      case 1: { return "Drive type could not be determined."; break; }
      case 2: { return "Removable drive.";                    break; }
      case 3: { return "Local hard disk.";                    break; }
      case 4: { return "Network disk.";                       break; }
      case 5: { return "Compact disk.";                       break; }
      case 6: { return "RAM disk.";                           break; }
   }
   return "Explanation for Unknown Drive type " + v + " is absent";
}

String.prototype.buildGuid = function()
{
   if ( this.length != 32 ) return this;

   //   1.3.5.7 8    12   16   20
   // {53f56307-b6bf-11d0-94f2-00a0c91efb8b}
   return "{" + this.substr(  0,  8 ) + "-" +
                this.substr(  8,  4 ) + "-" +
                this.substr( 12,  4 ) + "-" +
                this.substr( 16,  4 ) + "-" +
                this.substr( 20, 12 ) + "}";
}

String.prototype.ConvertQWORD = function()// converts 32-bytes heximal string
{
//                                  .  .  .  .  x  x  y  y  z  z  t  t  t  t  t  t
//                                  00 02 04 06 08 10 12 14 16 18 20 22 24 26 28 30
// 3ab0aea1c467eb4fb392a1a746d349a7 3a b0 ae a1 c4 67 eb 4f b3 92 a1 a7 46 d3 49 a7
      var t = this.toLowerCase();
      return t.substr( 06, 02 ) + t.substr( 04, 02 ) + t.substr( 02, 02 ) + t.substr( 00, 02 ) +
             t.substr( 10, 02 ) + t.substr( 08, 02 ) + // 4 xx
             t.substr( 14, 02 ) + t.substr( 12, 02 ) + // 4 yy
             t.substr( 16, 02 ) + t.substr( 18, 02 ) + // 4 zz
             t.substr( 20, 12 ); // 12
}

String.prototype.invertHexString = function()
{
   var s = this;
   if ( s.length % 2 == 1 ) s = "0" + s;
   var t = "", p = s.length - 2;
   while ( p >= 0 ) { t += s.substr( p, 2 ); p -= 2; }
   return t;
}

String.prototype.UniqueToGUID = function()
{
   var t = this.substr( 0, 8 ) +
           this.substr( 8, 6 ).replace( "000010", "007e00" ) + // <<<
     this.substr( 14 );
   //t = this;
   return "{" + t.substr( 0, 8 ).invertHexString() + "-0000-0000-" +
   t.substr( 8, 4 ) + "-" + t.substr( 12 ) + "}";
}
String.prototype.getGUID = function()
{
   var GuidL = "{714ce430-d2a2-11e4-824f-806e6f6e6963}".length;
   if ( this.length < GuidL ) return this;
   return this.substr( this.indexOf( "{" ), GuidL );
}

function ShowObject( obj )
{//                ComponentInfo
   var MaxNameL = "InitialTimestamp".length;
   for ( var p in obj )
   {
      if ( p == obj.Index ) continue;
      if ( typeof( obj[ p ] ) == "undefined" )
        Out.StdOut.WriteLine( p.left( MaxNameL + 3 ) );
      else
        Out.StdOut.WriteLine( p.left( MaxNameL + 3 ) + obj[ p ] );
   }
   Out.StdOut.WriteLine( "\n" );
   return false;
}

//
// ClassDC, ClassSV, ClassLV instances are created by CollectionClass Constructor.
//

var DevicesCollection        = null; // will be replaced by the instance of the ClassDC
var StorageVolumesCollection = null; // will be replaced by the instance of the ClassSV
var LogicalVolumesCollection = null; // will be replaced by the instance of the ClassLV

//
// CollectionClass Constructor
//

//
// This Class Constructor analize CollectionName argument
// and creates DevicesCollection, StorageVolumesCollection or
// LogicalVolumesCollection Collection objects. If Constructor
// argument is not equal to one of the names mentioned above
// it sets Class instance to null.
// Class exports following methods:
//
// Build         = function()
// Show          = function()
//

// Class instance object has following properties:
// Name
// filter - an object used when adding properties of the input
//          object to the objec already kept in the collection.
// MaxPL  - number which is used by the method Show to align
//          properties names. String prototype left should be
//          accessed from CollectionClass as Class method Show
//          use this method.
//
/*
"01.149.59 June 19, 2015" - GetCurrentUserSID( regInstance ) was implemented;
"01.149.60 June 19, 2015" - GetCurrentUserSID( regInstance ) relocated into
                            StdRegClass.
"01.149.61 June 19, 2015" - Sibling implemented at June 20.
"01.149.63 June 20, 2015" - failed to debug at June 20.
"01.149.65 June 21, 2015" - yet not WAD June 21.
"01.149.66 June 21, 2015" -
"01.149.67 June 21, 2015";
"01.149.68 June 21, 2015"
"01.149.69 June 21, 2015" - June 23, implemented ParseDeviceIdent,
                            now all but Mbr are matched.
"01.149.70 June 23, 2015" - really it was BAD idea to use Offsets as a keys.
                            and MatchPartitions - WAD for VolumeGUID
                            keys only without any Offset keys. Now NEW function,
                            MatchVolumesAndDisks should be created.
"01.149.71 June 23, 2015" - this is NEARLY finished: all letters are assigned,
                            Gpt / Mbr Style defined. But yet not Removable and
							DVD-ROM still exists in SiblingFor.
"01.149.72 June 24, 2015" - WAD, some clearence is necessary
"01.149.73 June 23, 2015" - Recognized VolumeSerialNumber in Unparsed Blob data
"01.149.75 June 25, 2015" - ShowBrief WAD, but had to decide about DevID
"01.149.77 June 25, 2015" - problem with CurrntUserSID under Windows 7.
"01.149.78 June 25, 2015" - problem with CurrntUserSID was fixed fast
"01.149.80-85             - have implemented Grouping and the last step was
                            today, July 1: group contain offsets of the group
                            members ==> if ( VolGroup.length < PartGroup.length )
                            THEN VolGroup has style Gpt and otherwise.
"01.149.85 July 01, 2015" - implemented VolGroup Style
"01.149.86 July 01, 2015" - SetObjectTypeByVolumeStorageString( obj, VSLine )
                            implemented for CollectLogicalVolumes and will be
                            used also by SetMountNameForMountPoint
"01.149.87 July 02, 2015" - SetObjectTypeByVolumeStorageString( obj, VSLine ) IMPROVED
"01.149.88 July 02, 2015" - due to changes in DevicesClasses.AddObjects array
                            as StorageVolumes as LogicalVolumes are correctly ordered
                            by the ParentIndex
"01.149.89 July 02, 2015" - SetMountNameForMountPoint - works, some some improvements
                            need to be implemented to exclude looping in groups
"01.149.90 July 04, 2015" - Gpt-Style volumes mounting improved: no more looping
"01.149.91 July 04, 2015" - function InternalError( obj, callerName ) implemented, July 06
"01.149.99 July 11, 2015"
"02.00 July 14, 2015"     - precedes optimization of the driver loop and implementing data from
                            HKLM\SYSTEM\HARDWARE
"02.01 July 22, 2015"     - new ordering of CPC\Volume handling,
Number type of CurrentVersionbject.CurrentBuild
*/
function CollectionClass( StdRegInstance )// June 28 // July 11 UPDATE, no more CollectionName argument
{
   //
   // CollectionClass Constructor starts after all collections Buildes
   // search it by the tag "CollectionClassConstructor"
   //
   var Version = "02.02 July 28, 2015";

   this.GetVersion = function()
   {
      return Version;
   }

   this.OutBuffers = null;

   this.Out = {};
   this.Out.StdErr = WScript.StdErr;
   this.Out.StdOut = WScript.StdOut;

   //
   // This is TERMINATOR common for all Collections Builders
   //
   function InternalError( obj, callerName )
   {
      Out.StdErr.WriteLine( "\n" );
      Out.StdErr.WriteLine( "*** Class" + callerName +
      " Incorrect object detected in the input array. Object properties follows:" );
      Out.StdErr.WriteLine( "\n" );
      for( var p in obj )
      {
         Out.StdErr.WriteLine( p.left( 20 ) + " " + obj[ p ] );
      }
      Out.StdErr.WriteLine( "\n" );
      Out.StdErr.WriteLine( "*** Quit from the Class " + callerName + " ***" );
      WScript.Quit();
   }
   //
   // This is index verificator common for SV / LV
   //
   function VerifyIndex( obj, index, callerName )
   {
      if( typeof( obj   ) == "undefined" || obj == null
      ||  typeof( index ) != "number" )
      {
         Out.StdErr.WriteLine( "\n" );
         Out.StdErr.WriteLine( "*** Class" + callerName + " incorrect arguments for VerifyIndex" );
         Out.StdErr.WriteLine( "*** typeof( index ): "+ typeof( index ) + " " +
		 ( typeof( index ) == "number" ? index: "" ) );
         Out.StdErr.WriteLine( "*** typeof( obj ): "+ typeof( obj ) + " IsNull " + ( obj == null ) );
         Out.StdErr.WriteLine( "*** Quit from the Class " + callerName + " ***" );
         WScript.Quit();
      }

	  if ( typeof( obj[ index ] ) == "undefined" || obj[ index ] == null
      ||   typeof(  obj[ obj[ index ] ].length ) != "number" )
      {
         InternalError( obj, callerName );
      }
      return true;
   }

   ////////////////-Collection-Class-Function-ClassDC-////////////////////////////
   //                                                                           //
   // When collecting objects to add them with this function, we get objects    //
   // properties from the TWO sources:                                          //
   // 1. Device Driver created enumeration which contains TWO properties:       //
   //    OrderNumber and PnPDeviceID                                            //
   // 2. Dump storage which contains a lot of DETAILED properties for each      //
   //    of the Device ever being attached to the system. Each object in        //
   //    dump storages can be matched with PnPDeviceID which was got from       //
   //    the Device Driver Enumeration. Algorithm used below excludes           //
   //    LOOPING with the objects of the Dump Storage and use DIRECT access     //
   //    path to the necessary Dump Storage object.                             //
   //                                                                           //
   ///////////////////////////////////////////////////////////////////////////////
   //
   // Driver Enumerations : all of them are located in the Registry subpath
   // HKLM\SYSTEM\CurrentControlSet\Services and includes the following
   // Enumerations ordered by alphabeth :
   //
   // *** cdrom Service Enumeration ****                               // ClassDC
   //
   // Contains in subpath \Enum enumerated list of all of the CdRom / DVD - ROM
   // devices including Internal, USB and Virtual. It may looks like :
   //
   // HKLM\SYSTEM\CurrentControlSet\Services\cdrom\Enum]
   // "0" = "SCSI\\CdRom&Ven_Msft&Prod_Virtual_DVD-ROM\\2&1f4adffe&0&000003"
   // "Count" = dword : 00000002
   // "NextInstance" = dword : 00000002                                     // ClassDC
   // "1" = "SCSI\\CdRom&Ven_Msft&Prod_Virtual_DVD-ROM\\2&1f4adffe&0&000004"
   //
   // *** disk Service Enumeration ****
   //
   // This Enumeration is Windows version dependent : regardless Windows
   // version it contains an ordered list of the PnPDeviceID for for
   // Internal HDs only.
   //
   // --- Internal HDs ---                                               // ClassDC
   //    since Windows Edition Windows NT 3.50 in which data base Registry
   //    have appeared for the 1 - st time
   //
   // --- USB 2.0 connected HDs ---
   //    since Windows Edition Windows XP
   //
   // --- Virtual HDs, VHDs ---
   //    since Windows Edition Windows 7                                 // ClassDC
   //
   // --- Memory Cards ( SD / MMC / ) ---
   //    since Windows Edition Windows 8
   //
   // --- USB 2.0 connected Flash - sticks ---
   //    since Windows Edition Windows XP
   //
   // --- USB 3.0 connected HDs and Flash - sticks ---
   //    since Windows Edition Windows 8.0                                // ClassDC
   //
   // *** EhStorClass Enumeration ****
   //
   //    at least since Windows Edition Windows 7 or may be Vista
   //
   // Contains ordered list of all of the Devices BUT CdRoms :
   // Internal HDs, USB - connected HDs, USB Flash - sticks,
   // VHDs, SD - cards. It belongs to the group SCSI class and thus
   // should hanle all the Devices attached to SCSI
   //
   // *** fdc Service Enumeration ***                                  // ClassDC
   //
   // --- floppy disks readers ---
   //    since Windows Edition Windows NT 3.50
   //
   // *** flpydisk Service Enumeration ****
   //
   // --- floppy disks ---
   //    since Windows Edition Windows NT 3.50
   //
   // *** mountmgr Service Enumeration ****                             // ClassDC
   //
   //    since Windows Edition Windows XP
   //    TILL  Windows Edition Windows 8
   //
   // Enumeration subkey content looks like :
   //
   // HKLM\SYSTEM\CurrentControlSet\services\mountmgr\Enum]
   // "0" = "Root\\LEGACY_MOUNTMGR\\0000"
   // "Count" = dword : 00000001
   // "NextInstance" = dword : 00000001
   //
   // *** partmgr Service Enumeration ****                               // ClassDC
   //
   //    at least since Windows Edition Windows XP
   //
   // Contains ordered list of all of the Devices BUT CdRoms :
   // Internal HDs, USB - connected HDs, USB Flash - sticks,
   // VHDs, SD - cards. Since Windows 8 content of this Enumeration
   // and Orderer Numbers are the same as foor the disk service.
   // Seems this driver is a secondary one related to disk service
   // and is signalled by the disk service to activate volmgr service       // ClassDC
   // as it contains reference on the volmgr service.
   //

   // Curious fact about the role of the Case sensitivity in the Registry : )

   //                          +----------- Upper Case 's' in services
   //                          |        +-- Upper Case 1 - st character in the driver name
   // Windows XP:              V        V
   // SYSTEM\CurrentControlSet\Services\Cdrom
   // SYSTEM\CurrentControlSet\Services\Disk
   // SYSTEM\CurrentControlSet\Services\PartMgr
   // SYSTEM\CurrentControlSet\Services\VolSnap

   //                          +------------ Lower Case 's' in services
   //                          |        +--- Lower Case 1 - st character in the driver name
   // Windows 7:               V        V
   // SYSTEM\CurrentControlSet\services\cdrom
   // SYSTEM\CurrentControlSet\services\disk
   // SYSTEM\CurrentControlSet\services\sffdisk
   // SYSTEM\CurrentControlSet\services\partmgr
   // SYSTEM\CurrentControlSet\services\volsnap

   //                          +------------- Upper Case 's' in services
   //                          |        +---- Lower Case 1 - st character in the driver name
   // Windows 8 and above:     V        V
   // SYSTEM\CurrentControlSet\Services\cdrom
   // SYSTEM\CurrentControlSet\Services\disk
   // SYSTEM\CurrentControlSet\Services\rdyboost
   // SYSTEM\CurrentControlSet\Services\volmgr
   // SYSTEM\CurrentControlSet\Services\volsnap

   // just have published it at: http://pcportal.org.ru/forum/60-7218-176794-16-1436503166

   function ClassDC( regObj )                                             // ClassDC
   {
      this.Count = 0; // DevicesCollection Count Property                 // ClassDC

      var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE                         // ClassDC
      var filter = {
         "Capabilities":  true,
         "ClassGUID":     true,
         "FriendlyName":  true,
         "DiskId":        true,
         "CompatibleIDs": true,
         "ConfigFlags":   true,
         "Mfg":           true,
         "Service":       true,
         "HardwareID":    false,
         "DeviceDesc":    false,
         "ContainerID":   false,
         "LocationInformation": false, // 12 value names
         "CustomPropertyCacheDate": false // sff_disk property, Windows 7   // ClassDC
      };
      var sff_disk_filter = {
         "Class":                   true,  // sff_disk property, Windows 7
         "LowerFilters":            true,  // sff_disk property, Windows 7
         "CustomPropertyHwIdKey":   true   // sff_disk property, Windows 7
      };

      function SetRemovableProps( obj )
      {
         obj.NumberOfSV   = 1;
         obj.SVGroup      = "";
         obj.NumberOfLV   = 1;
         obj.LVGroup      = "";
         obj.LVGroupStyle = "";
         return obj;
      }
      function SetTypeSubtype( obj )                                        // ClassDC
      {
         // Intrface: IDE, SCSI, SD, TAPE
         // Service:  disk, sffdisk, cdrom
         var ts        = obj.PnPDeviceID.split( "\\" );                     // ClassDC
         var Interface = ts[0];
         var Details   = ts[1]
         var Service   = obj.Service;
         var IsVirtual = ( Details.toLowerCase().indexOf( "virtual" ) > - 1 );
         var IsFlash   = ( Details.toLowerCase().indexOf( "flash"   ) > - 1 );
         var IsUsb     = ( Interface == "USBSTOR" );

         obj.LVGroupStyle = ""; // common property regardless Type, Subtype
         obj.NumberOfLV   = 1;  // common property regardless Type, Subtype
         obj.LVGroup      = ""; // common property regardless Type, Subtype

         if ( obj.Service == "cdrom" )                                      // ClassDC
         {
            obj.Type = "DVD-ROM";
            if ( IsVirtual )
            {
               obj.Subtype = "Virtual";
               return obj;                                                  // ClassDC
            }
            if ( IsUsb )
            {
               obj.Subtype = "USB";
               return obj;
            }

            obj.Subtype = "Internal";

            return obj;                                                      // ClassDC
         }
         if ( obj.Service == "sffdisk" )                                     // ClassDC
         {
            obj.Type = "Removable";
            if ( IsUsb ) obj.Subtype = "USB Memory Card";
            else         obj.Subtype = "SD";
            obj = SetRemovableProps( obj );
            return obj;
         }
         if ( obj.Service == "disk"
         &&   Interface   == "SD"   )                                        // ClassDC
         {
            obj.Type = "Removable";
            if ( IsUsb ) obj.Subtype = "USB Memory Card";
            else         obj.Subtype = "SD";
            obj = SetRemovableProps( obj );
            return obj;
         }
         if ( IsFlash )                                                      // ClassDC
         {
            obj.Type = "Removable";
            obj.Subtype = "Flash";
            obj = SetRemovableProps( obj );
            return obj;
         }

         if ( obj.Service == "disk" )
         {
            obj.Type = "HD";
            if ( IsUsb )
            {
               obj.Subtype = "USB";                                          // ClassDC
            }
            else if ( IsVirtual )
            {
               obj.Subtype = "VHD";
            }
            else
            {
               obj.Subtype = "Internal";
            }

            obj.NumberOfSV   = 0;  // number of the childs in the StorageVolumes group
            obj.SVGroup      = ""; // comma-separated list of the childs Offset property values

            obj.NumberOfLV   = 0;  // number of the childs in the LogicalVolumes group
            obj.LVGroup      = ""; // comma-separated list of the childs Offset property values
            obj.LVGroupStyle = ""; // "Mbr" or "Gpt"

            return obj;
         }
         return obj;
      }// End-of-function SetTypeSubtype( obj )                                  // ClassDC

      function SetProperties( sObj, tObj )                                       // ClassDC
      {
         var pType, name, value;
         for ( var i = 0; i < sObj.length; i++ )
         {
            name  = sObj[i].name;
            value = sObj[i].value;

            pType = filter[ name ];

            if ( pType )
            {
               if ( "Mfg"        == name                                          // ClassDC
               || "FriendlyName" == name
               || "DeviceDesc"   == name )
               {
                  value = value.substr( 1 + value.indexOf( ";" ) );
               }
               tObj[ name ] = value;
            }

            if (   obj.PnPDeviceID.indexOf( "VID_" ) > - 1 )                       // ClassDC
            {
               pType = sff_disk_filter[ name ];
               if ( pType )
               {
                  tObj[ name ] = value;
               }
            }
         }
         return tObj;
      }
      String.prototype.ltrim = function()
      {
	      return this.replace( /^(\s*)/, "" );
      }

      //
      // getting hardware device properties from
      // HKLM\HARDWARE\DEVICEMAP\Scsi\Scsi Port m\Scsi Bus n\Target Id k\Logical Unit Id l                                                                                // ClassDC
      //
      // it became clear that it make sense to read
      // 1. only for internal HD
      // 2. only if BuildNumber > "7601"
      // 3. only SerialNumber REG_SZ
      // But previously it is necessary to travers till
      // HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id M,
      // that it till the subpath which name starts with "Logical Unit Id "
      //
      function getSerials()// July 25
      {
         var serials = [];
         var BN = CurrentVersionObject.CurrentBuild;

         if ( BN < 9600 ) return serials;

         var tmp1, tmp2, tmp3, tmp4, p1, p2, p3, p4, SN;
         var path = "HARDWARE\\DEVICEMAP\\Scsi";
         tmp1 = regObj.RegEnumKey( HKLM, path ); // ***
////Out.StdOut.WriteLine( "getSerials: tmp1.length="+tmp1.length + " path=" + path );
         // HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id M
         //                          i          j          k           l
         for ( var i = 0; i < tmp1.length; i++ )
         {
            p1 = path + "\\" + tmp1[ i ];
            tmp2 = regObj.RegEnumKey( HKLM, p1  ); // ***
////Out.StdOut.WriteLine( "getSerials: tmp2.length="+tmp2.length + " p1=" + p1 );
            for ( var j = 0; j < tmp2.length; j++ )
            {
               p2 = p1 + "\\" + tmp2[ j ];
               tmp3 = regObj.RegEnumKey( HKLM, p2  ); // ***
////Out.StdOut.WriteLine( "getSerials: tmp3.length="+tmp3.length + " p2=" + p2 );
               for ( var k = 0; k < tmp3.length; k++ )
               {
                  p3 = p2 + "\\" + tmp3[ k ];
                  tmp4 = regObj.RegEnumKey( HKLM, p3  ); // ***
////Out.StdOut.WriteLine( "getSerials: tmp4.length="+tmp4.length + " p3=" + p3 );
                  for ( var l = 0; l < tmp4.length; l++ )
                  {
                     p4 = p3 + "\\" + tmp4[ l ];
                     SN = regObj.RegGetStringValue( HKLM, p4, "SerialNumber" ); // ***
                     if ( SN == null ) return serials;//break;
////Out.StdOut.WriteLine( serials.length + " " + SN );
                     serials[ serials.length ] = SN.ltrim();
                  }
               }
            }
         }
         return serials;
      }


      /* Example of the values read in the loop below
      [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\cdrom\Enum]
      "0"="SCSI\CdRom&Ven_Msft&Prod_Virtual_DVD-ROM\2&1f4adffe&0&000003"
      "Count"=dword:00000002
      "NextInstance"=dword:00000002
      "1"="SCSI\CdRom&Ven_Msft&Prod_Virtual_DVD-ROM\2&1f4adffe&0&000004"

      [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\partmgr\Enum]
      "0"="SCSI\Disk&Ven_&Prod_ST9320423AS\4&3516b3b5&0&000000"
      "Count"=dword:00000007
      "NextInstance"=dword:00000007
      "1"="SCSI\Disk&Ven_TOSHIBA&Prod_MK1646GSX\4&3516b3b5&0&010000"
      "2"="SD\DISK&Generic&SA08G&0.4\6&447d92&0&9c053461&0"
      "3"="SCSI\Disk&Ven_Msft&Prod_Virtual_Disk\2&1f4adffe&0&000001"
      "4"="SCSI\Disk&Ven_Msft&Prod_Virtual_Disk\2&1f4adffe&0&000002"
      "5"="USBSTOR\Disk&Ven_Hitachi&Prod_HTS723232L9A360&Rev_\Hitachi_HT100219FCC400NEJTBU5G&0"
      "6"="USBSTOR\Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100\08AD000000002788&0"

      -------------------------------------------InputForDevicesCollection-------------DiskId-------------------------------
       0 SCSI\CdRom&Ven_Msft&Prod_Virtual_DVD-ROM\2&1f4adffe&0&000003                  null
       1 SCSI\Disk&Ven_&Prod_ST9320423AS\4&3516b3b5&0&000000                           {714ce426-d2a2-11e4-824f-806e6f6e6963}
       2 SCSI\Disk&Ven_TOSHIBA&Prod_MK1646GSX\4&3516b3b5&0&010000                      {714ce427-d2a2-11e4-824f-806e6f6e6963}
       3 SD\DISK&Generic&SA08G&0.4\6&447d92&0&9c053461&0                               {714ce424-d2a2-11e4-824f-806e6f6e6963}
       4 SCSI\Disk&Ven_Msft&Prod_Virtual_Disk\2&1f4adffe&0&000001                      {a64f86e3-06e5-11e5-b690-0c607688d174}
       5 SCSI\Disk&Ven_Msft&Prod_Virtual_Disk\2&1f4adffe&0&000002                      {a64f86f5-06e5-11e5-b690-0c607688d174}
       6 USBSTOR\Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100\08AD000000002788&0      {0783c72b-0b70-11e5-8316-0c607688d174}
       7 USBSTOR\Disk&Ven_USB_2.0&Prod_Storage_Device&Rev_0100\00042222200000055949&0  {a03ccd8c-06ee-11e5-8307-0c607688d174}
      */

      var HKLM   = 0x80000002;                                                      // ClassDC

      var devs = [], pnpkeys = [], pnpid;
      var obj = {}, vObj, name, value, rc, tmp, prefix, Unique;
      var pType, vals, pnpkey, sff_pnpkey, DiskIdPath, tstamp;

      //var services = [ "cdrom", "sffdisk", "flpydisk", "disk" ];// 2.00 list of drivers
      // July 22, these two are enough to get all devices PnPDEviceIds
      var services = [ "cdrom", "partmgr"];

      var servpath = "SYSTEM\\CurrentControlSet\\services\\";
      var hpath = "HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\0\\DiskController\\0\\DiskPeripheral\\";
      var devnum = 0, fpath, tmp, serials, serialsIndex = 0;

      // An array of the Devices objects this function builds and returns to the caller
      var Devices = [];

      for ( var p = 0; p < services.length; p++ )// July 07                        // ClassDC
      {
         devs = regObj.RegGetAllValues( HKLM, servpath + services[p] + "\\Enum" ); // ***

         if ( services[ p ] == "partmgr" )
         {
            serials = getSerials(); // July 25
         }

         if ( devs == null || typeof( devs ) != "object"
         ||   devs.length == 0 ) continue; // omit interface without any device serviced

         for ( var i = 0; i < devs.length; i++ )
         {
            if ( devs[ i ].name == "Count"
            ||   devs[ i ].name == "INITSTARTFAILED"
            ||   devs[ i ].name == "NextInstance"
            ||   devs[ i ].value.indexOf( "LEGACY_" ) > - 1 ) continue;             // ClassDC

            obj = { "PnPDeviceID": devs[ i ].value };
            obj.OrderIndex = devs.length; // set OrderIndex property

            var ppath = "SYSTEM\\CurrentControlSet\\Enum\\";
            prefix    = ppath.length;
            pnpkey    = devs[ i ].value; //////// SD\VID_02&OID_544d&PID_SA08G&REV_0.4\5&171d8613&0&0

            if ( pnpkey.indexOf( "VID_" ) > - 1 )
            {
               obj.VID_PnPDeviceID = pnpkey; // correct PnPDeviceID for SD will be set later
            }

            vals = regObj.RegGetAllValues( HKLM, ppath + "\\" + pnpkey ); // **

            obj  = SetProperties( vals, obj ); // set properties                     // ClassDC

            DiskIdPath    = ppath + "\\" + pnpkey + "\\Device Parameters\\Partmgr";
            TimestampPath = ppath + "\\" + pnpkey + "\\Device Parameters\\Storport";

            obj.DiskId = regObj.RegGetStringValue( HKLM, DiskIdPath, "DiskId" ); // ***

            //
            // Windows XP has no \Device Parameters\Partmgr subkey as this
            // subkey is absent in all Windows versions for cdrom service driver.
            // No matter, we will set DiskId value from the PnPDeviceID with
            // replacement of the "\" to "#" to make it once and exclude likewise
            // conversion when collecting StorageVolumes and LogicalVolumes
            //
            if ( obj.DiskId == null )
            {
               obj.DiskId = obj.PnPDeviceID.replace( /\\/g, "#" );                     // ClassDC
               Unique = obj.DiskId;
            }
            else
            {
               Unique = obj.DiskId.substr( 1, 8 ); // we take GUID Field 1
            }

                                          // for each object of each collection
            obj.DCUniqueID = Unique;      // it's UniqueID has a prefix being equal
                                          // to the collection ShortName
            obj = SetTypeSubtype( obj );  // Detect Type and Subtype of the device
                                          // We 100% correctly detects here CdRoms      // ClassDC
                                          // Memory cards, Flashes and USB Disks BUT as Flashes
                                          // and Memory cards CAN be partitioned then we do not
                                          // set "Partition" property here and use "HD" instead.
                                          // SV and LV will have an opportunity to DETECT
                                          // partitioned Removables and change a Type for them
                                          // from the Removable to Partition if necessary

            // For the Devices Collection to decide is DCUniqueID derived from the DiskId GUID
            // or from the PnPDeviceID it is enough to verify 1-st character of the DiskId:
            // if it is equal to "{" then DCUniqueID presents Field 1 of the DiskId and
            // PnPDeviceID with "\" replaced by "#" otherwise.

            tstamp = regObj.RegGetQWORDValue( HKLM, TimestampPath, "InitialTimestamp" ); // ***

            if ( tstamp != null )                                                        // ClassDC
            {
               tstamp = regObj.RegDateToDate( tstamp ).toString(); // ***
            }

            obj.Timestamp = tstamp;
            obj.SerialNumber = "";

            //
            // Verify that an input object has necessary properties
            // and IMMEDIATLY terminates if any one is undefined
            //

            if ( typeof( obj.PnPDeviceID ) != "string"                                   // ClassDC
            ||   typeof( obj.Type        ) != "string"
            ||   typeof( obj.DCUniqueID  ) != "string"
            ||   typeof( obj.DiskId      ) != "string" )// this property is not defined for CdRom and in XP
            {                                           // and was created "by hand" in the function
               InternalError( obj, "DC" );              // CollectDevices
            }

            obj.DeviceIndex = this.Count; // assign an index to DevicesCollection to the object

            //
            // Create DevicesCollection Index property for                               // ClassDC
            // the object property UniqueID.
            //

            this[ obj.DCUniqueID ] = this.Count;

            //
            // When building the SV / LV Collections there is no way to detect           // ClassDC
            // Parent Device by DiskId GUID as it is absent in the
            // Device identification string read from the Services\volsnap\Enum and
            // MountPoint2\CPC\Data binary blob.
            // Thus it is necessary to create Direct access key in the DevicesCollection
            // and assign to this key the same index as to the object we are going to
            // place into DevicesCollection.
            //

            if ( obj.DiskId.charAt(0) == "{" )// and now this code will work even in XP  // ClassDC
            {
               this[ obj.PnPDeviceID.replace( /\\/g, "#" ) ] = this.Count;
            }

            if ( obj.Type == "HD" && obj.Subtype == "Internal" )                          // ClassDC
            {
               if ( CurrentVersionObject.CurrentBuild >= 9600 )
               {
                  obj.SerialNumber = serials[ serialsIndex++ ]; // July 25
               }

               fpath = hpath + devnum.toString();
               ++devnum;
               props = regObj.RegGetAllValues( HKLM, fpath );  // *** read all values     // ClassDC
               /*
               "Component Information"=00000000000000000000000ffffffff
               "Identifier"="0685a158-1036c1c4-A"
               "Configuration Data"=01000000000000000000000001000000050000001000000000000000000000000000000000020000ff0300003f000000f0000000"
               */

               for ( var p = 0; p < props.length; p++ )                                  // ClassDC
               {
                  switch( props[ p ].name )
                  {
                     case "Component Information": obj.ComponentInfo = props[ p ].value; break;
                     //case "Configuration Data":    obj.ConfigData    = props[ p ].value; break;
                     // as StdRegProv doesn't provide a method to read REG_FULL_RESOURCE_DESCRIPTOR
                     // and an attempt to use GetBinary returns null then we ignore this property
                     case "Configuration Data":    continue; break;
                     case "Identifier":            obj.Identifier    = props[ p ].value; break;
                     // on a case that a new property will appear :)
                     default:                      obj[ props[ p ].name ] = props[ p ].value;
                  }
               }

               if( obj.Identifier.substr( 9, 8 ) == "00000000" )                          // ClassDC
               {
                  obj.LVGroupStyle = "Gpt";
               }
			      else
               {
                  obj.Signature = obj.Identifier.substr( 9, 8 );
                  obj.LVGroupStyle = "Mbr";// AM NOT SURE that this rule IS CORRECT, has no Internal Gpt
               }
            }

            //
            // place updated input object into the                                        // ClassDC
            // DevicesCollection at the index = Count.
            // Thus now this object can be accessed as:
            // DevicesCollection[ DevicesCollection[ DCUniqueID ] ].
            // DevicesCollection[ DCUniqueID ] - is an index [ 0, N ]
            // where N is arr.length and DevicesCollection.Count
            // at the end of the loop.
            //
            obj.OrderIndex = this.Count;
            this[ this.Count ] = obj;

            this.Count++;   // increment DevicesCollection.Count property

         }// End-of-devs-loop:-set-properties-i-loop: 14 properties for each of the objects

      }// End-of-Interfaces-loop: [ "cdrom", "partmrg" ], really only cdom & disk since 8/8.1

      this.Show = function()                                        // ClassDC
      {                                                             // ClassDC
         var cnt = this.Count;                                      // ClassDC
         Out.StdOut.WriteLine( "\n" );                              // ClassDC
         Out.StdOut.WriteLine( "There are " + cnt + " objects in DevicesCollection" );
         Out.StdOut.WriteLine( "\n" );                              // ClassDC
         for( var i = 0; i < cnt; i++ )                             // ClassDC
         {                                                          // ClassDC
            ShowObject( this[ i ] );                                // ClassDC
         }                                                          // ClassDC
         return false;                                              // ClassDC
      }                                                             // ClassDC

   }// End-of-ClassDC: DevicesCollection                            // ClassDC-Trailing-Tag

   ////////////////-Collection-Class-Function-ClassSV-////////////////////////////////////
   //                                                                                   //
   // Function is called from the function CollectionClass method Build                 //
   //                                                                                   //
   // Function loops by the items of the values read from the volsnap\\Enum,            //
   // set rather few properties by a very simle parsing of the value strings            //
   // to the target object which then is placed into the output array.                  //
   // Function get access to the Parent Devices Collection object using it's            //
   // own DevUniqueID property derived by a simple parsing of the input Storage\\Volume //
   // string. Function immediatly sets obj.ParentIndex property and then it UPDATES     //
   // DevUniqueID property                                                              //
   // An array of the objects created is then used by the Build method to build the     //
   // DevicesCollection.                                                                //
   // July 09, NEW property, DevUniqueID will be set instead of DevID:                  //
   //                                                                                   //
   ///////////////////////////////////////////////////////////////////////////////////////
   //
   function ClassSV( regObj )                                                      // ClassSV
   {
      this.Count = 0;

      //_??_SD#VID_02&OID_544d&PID_SA08G&REV_0.4#5&171d8613&0&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      // SYSTEM\CurrentControlSet\services\volsnap\Enum

      /*                                                                    // ClassSV
      Before Parsing----------------------------------------------------------------------
      STORAGE\Volume\_??_SD#VID_02&OID_544d&PID_SA08G&REV_0.4#5&171d8613&0&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      STORAGE\Volume\_??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      STORAGE\Volume\{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000000007E00
      STORAGE\Volume\{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000016260000
      STORAGE\Volume\{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000F61CEC000
      STORAGE\Volume\{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000002078900000
      STORAGE\Volume\{714ce427-d2a2-11e4-824f-806e6f6e6963}#0000000000100000
      STORAGE\Volume\{714ce427-d2a2-11e4-824f-806e6f6e6963}#0000001CB7E5A000
      STORAGE\Volume\{a64f86e3-06e5-11e5-b690-0c607688d174}#0000000000004400
      STORAGE\Volume\{a64f86e3-06e5-11e5-b690-0c607688d174}#0000000002010000
      STORAGE\Volume\{a64f86e3-06e5-11e5-b690-0c607688d174}#000000000E810000
      STORAGE\Volume\{a64f86e3-06e5-11e5-b690-0c607688d174}#0000000018E10000
      STORAGE\Volume\{a64f86f5-06e5-11e5-b690-0c607688d174}#0000000000004400
      STORAGE\Volume\{a64f86f5-06e5-11e5-b690-0c607688d174}#0000000002010000
      STORAGE\Volume\_??_USBSTOR#Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100#08AD000000002788&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      STORAGE\Volume\{a03ccd8c-06ee-11e5-8307-0c607688d174}#0000000000004400
      STORAGE\Volume\{a03ccd8c-06ee-11e5-8307-0c607688d174}#0000000008100000
      STORAGE\Volume\{a03ccd8c-06ee-11e5-8307-0c607688d174}#0000000088100000
      After Parsing----------------------------------------------------------------------
      DevID={714ce426-d2a2-11e4-824f-806e6f6e6963},         Offset=0000000000007E00
      DevID={714ce426-d2a2-11e4-824f-806e6f6e6963},         Offset=0000000016260000
      DevID={714ce426-d2a2-11e4-824f-806e6f6e6963},         Offset=0000000F61CEC000
      DevID={714ce426-d2a2-11e4-824f-806e6f6e6963},         Offset=0000002078900000
      DevID={714ce427-d2a2-11e4-824f-806e6f6e6963},         Offset=0000000000100000
      DevID={714ce427-d2a2-11e4-824f-806e6f6e6963},         Offset=0000001CB7E5A000
      DevID=SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0
      DevID=SD#VID_02&OID_544d&PID_SA08G&REV_0.4#5&171d8613&0&0
      DevID={a64f86e3-06e5-11e5-b690-0c607688d174},         Offset=0000000000004400
      DevID={a64f86e3-06e5-11e5-b690-0c607688d174},         Offset=0000000002010000
      DevID={a64f86e3-06e5-11e5-b690-0c607688d174},         Offset=000000000E810000
      DevID={a64f86e3-06e5-11e5-b690-0c607688d174},         Offset=0000000018E10000
      DevID={a64f86f5-06e5-11e5-b690-0c607688d174},         Offset=0000000000004400
      DevID={a64f86f5-06e5-11e5-b690-0c607688d174},         Offset=0000000002010000
      DevID=USBSTOR#Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100#08AD000000002788&0
      DevID={a03ccd8c-06ee-11e5-8307-0c607688d174},         Offset=0000000000004400
      DevID={a03ccd8c-06ee-11e5-8307-0c607688d174},         Offset=0000000008100000
      DevID={a03ccd8c-06ee-11e5-8307-0c607688d174},         Offset=0000000088100000
      */
                                                                            // ClassSV
      var GuidL = "{714ce426-d2a2-11e4-824f-806e6f6e6963}".length;
      var HKLM  = 0x80000002;// HKEY_LOCAL_MACHINE

      var obj, tmp, devid, offset, ParentType, index;

      var ChildN    = 1;
      var PrevDevID = "";
      var IsOffset  = false;

      var TColl = {};  // temporary collection for SV - objects

      var Count = 0;   // number of the objects placed into the temporary collection

      var servpath  = "SYSTEM\\CurrentControlSet\\services\\volsnap\\Enum";
      var svols = regObj.RegGetAllValues( HKLM, servpath ); // *** read all values

      // July 26: this fragment HAD to be changed, DWORD Count should be read at 1-st and
      // then i.tostring(), i = 0, i < Count, i++. This will GARANTEE correct ordering of
      // the childs for the same parent.
      for ( var i = 0; i < svols.length; i ++ )
      {  // vols[i].value = Root\LEGACY_VOLSNAP\0000
         if ( svols[ i ].name == "Count"
         ||   svols[ i ].name == "NextInstance"                              // ClassSV
         ||   svols[ i ].name.indexOf( "LEGACY_"  ) > - 1 // July 05, seems I've mixed up name and value :)
         ||   svols[ i ].value.indexOf( "LEGACY_" ) > - 1 ) continue;

         obj = {};

         tmp = svols[ i ].value.substr( "STORAGE\\Volume\\".length );        // ClassSV

         devid    = tmp.substr( 0, GuidL );                     // it CAN be GUID
         offset   = tmp.substr( GuidL + 1, 16 ).toLowerCase();  // it CAN be Offset
         IsOffset = tmp.charAt( GuidL ) == "#"  &&  // verify that Offset separator is present
         offset.match( /[0-9a-f]/g )                // and CORRECT Offset string follows separator

         devid = devid.charAt( 0 ) == "{" ? devid.substr( 1, 8 ) : tmp.replace( /\\/g, "#" );
         if ( "_??_" == devid.substr( 0, 4 ) )
         {
            devid = devid.substr( 4 );                                      // ClassSV
            devid = devid.split( "#{" )[ 0 ];
         }

         index = DevicesCollection[ devid ];    // DevicesCollection creates for each of such device

         if ( typeof( index ) != "number"       // Direct Access key which we use now to get an access
         ||   index < 0                         // to the Parent Device. Otherwise it is INTERNAL
         ||   index > DevicesCollection.Count ) // ERROR and we terminate execution.
         {
            InternalError( obj, "SV" );                              // ClassSV
         }

         // we got correct Parent index and CAN COPY it's DCUniqueID which value will be GUID
         obj.ParentIndex = index;

         obj.DCUniqueID  = DevicesCollection[ index ].DCUniqueID;

         if ( IsOffset )                //
         {                              // DevicesCollection PnPDeviceID string parser have
            obj.Type   = "Partition";   // correctly detected Type of the device as Removable.
            obj.Offset = offset;        // But it appeared to be partitioned and thus we set
         }                              // here Type = "Partition" to handle this device correctly.
         else                           // For removables all the device is ONE extent startting 0.
         {                              //
            obj.Offset = "0000000000000000";
            obj.Type = "Removable";
         }

         obj.DCUniqueID  = DevicesCollection[ obj.ParentIndex ].DCUniqueID;                                                            // ClassSV
         ParentType = DevicesCollection[ obj.ParentIndex ].Type;                             // ClassSV

         //
         // now we can create SVUniqueID : as we have already defined Offset property for all
         // types of the Devices which comes here we can create it by merging Parent Device
         // DCUniqueID which is always Field 1 of the DiskId GUID and SV Offset property.
         // It will be Unique Id which has resemblance with a Parent Device and individual
         // characters of the current child. We can be SURE that all of the childs of the
         // same Parent Device will follow each other and the Offset value will be increased :
         // this is enabled by the volmngr ( ??? ) driver filter which is signalled by the
         // volsnap driver as soon as it created and placed into the Enum subpath StorageVolume
         // identification string.
         //

         obj.SVUniqueID = obj.DCUniqueID + obj.Offset;                      // ClassSV

         // we should control and correctly set ChildNumber property
         // Small fragment which follow provides correct ChildNumber
         // property assignment

         if ( obj.DCUniqueID != PrevDevID )
         {
            if ( PrevDevID != "" )
            {
               ChildN = 1;
            }
            PrevDevID = obj.DCUniqueID;                                     // ClassSV
         }

         obj.ChildNumber = ChildN;
         ++ ChildN;
         // and of the ChildNumber property support fragment                 // ClassSV
         // It's high time to get some more properties data from the Storage Dump
         // at Registry subpath given above. We will build precise full path to
         // the data we need and will read all of them. But we need to set precise
         // Registry path in which we will read properties values. As it was already
         // analysed above, variable tmp contains the last fragment of the path we need
         // regardles if it starts with a horns ( _ ? ? _ ) or GUID.
         //

         var ppath = "SYSTEM\\CurrentControlSet\\Enum\\STORAGE\\Volume\\";   // ClassSV
         var props = regObj.RegGetAllValues( HKLM, ppath + tmp );  // *** read all values

         /* these are an example values of the properties read by the code line above
         HKLM\SYSTEM\CurrentControlSet\Enum\STORAGE\Volume\_??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
         "Capabilities"=dword:000000b0
         "ContainerID"="{33b560f6-21b5-11e5-b2ff-806e6f6e6963}"
         "HardwareID"=hex(7):53,00,54,00,4f,00,52,00,41,00,47,00,45,00,5c,00,56,00,6f, 00,6c,00,75,00,6d,00,65,00,00,00,00,00
         "ClassGUID"="{71a27cdd-812a-11d0-bec7-08002be2092f}"
         "Service"="volsnap"
         "DeviceDesc"="@volume.inf,%storage\\volume.devicedesc%;Generic volume"
         "Driver"="{71a27cdd-812a-11d0-bec7-08002be2092f}\\0000"
         "Mfg"="@volume.inf,%msft%;Microsoft"
         "ConfigFlags"=dword:00000000
         */
         // we will take only SOME of the properties :                          // ClassSV
         // Capabilities, ContainerID which make sense for the horned guys only
         // as those without horns always has the same value {00000000 - 0000 - 0000 - ffff - ffffffffffff}
         // ClassGUID which will be the same for all of the objects, Service which again will have
         // the same value for all of the objects. We would have set Service and ClassGUID properties
         // "by hand" but it is BETTER to read them from the Registry on a case that something would
         // be changed by Microsoft.

         for ( var p = 0; p < props.length; p ++ )
         {
            if ( "Capabilities,ContainerID,ClassGUID,Service".indexOf( props[ p ].name ) > - 1 )
            {
               obj[ props[ p ].name ] = props[ p ].value;
            }
         }

         // that is all, just place an object prepared into the temporary collection  // ClassSV

         if ( typeof( TColl[ obj.ParentIndex ] ) == "undefined" )
         {
            TColl[ obj.ParentIndex ] = [];                                                      // ClassSV
         }

         pobj = DevicesCollection[ obj.ParentIndex ];
         pobj.SVGroup += pobj.SVGroup == "" ? obj.Offset : "," + obj.Offset;
         pobj.NumberOfSV++;
         DevicesCollection[ obj.ParentIndex ] = pobj;
         TColl[ obj.ParentIndex ][ TColl[ obj.ParentIndex ].length ] = obj;
         ++Count; // increment number of the SV objects collected

      } // End-of-the-i-loop-on-all-of-the-StorageVolumes-ids-created-by-the-volsnap-driver

      var nc, poj;
      var nd = DevicesCollection.Count;

      for ( var i = 0; i < nd; i ++ )
      {
         if ( DevicesCollection[ i ].Type == "DVD-ROM" ) continue;                    // ClassSV

         nc = TColl[ i ].length;
         for( var j = 0; j < nc; j ++ )
         {
            obj = TColl[ i ][ j ];
            obj.OrderIndex = this.Count;
            this[ this.Count ] = obj;
            ++this.Count;
         }
      }// End-of-fill-collection-loop

      this.Show = function()                                                          // ClassSV
      {                                                                               // ClassSV
         var cnt = this.Count;                                                        // ClassSV
         Out.StdOut.WriteLine( "\n" );                                                // ClassSV
         Out.StdOut.WriteLine( "There are " + cnt + " objects in StorageVolumesCollection" );
         Out.StdOut.WriteLine( "\n" );                                                // ClassSV
         for( var i = 0; i < cnt; i++ )                                               // ClassSV
         {                                                                            // ClassSV
            ShowObject( this[ i ] );                                                  // ClassSV
         }                                                                            // ClassSV
         return false;                                                                // ClassSV
      }                                                                               // ClassSV
   } // End-of-ClassSV                                                                // ClassSV-Trailing-Tag

   //
   // This function is common for CollectLogicalVolumes and
   // SetMountNameForMountPoint : both needs pasing of the
   // strings which presents StorageVolumes.
   //
   /*
   --------------------------------------------------------------------------------------------------------------------
   Input from MountedDevices :
   \\?\STORAGE#Volume#{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000000007E00#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}

   \\?\STORAGE#Volume#_??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
   _??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}

   _??_USBSTOR#Disk&Ven_Multiple&Prod_Card__Reader&Rev_1.00#058F63666438&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}

   Input from MountPoints2:
   \??\SCSI#CdRom&Ven_Msft&Prod_Virtual_DVD-ROM#2&1f4adffe&0&000001#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
   STORAGE\Volume\_??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
   STORAGE\Volume\_??_USBSTOR#Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100#08AD000000002788&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
   STORAGE\Volume\{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000000007E00
   --------------------------------------------------------------------------------------------------------------------
   */
   function SetObjectTypeByVolumeStorageString( obj, VSLine )
   {
      var GuidL    = "{714ce426-d2a2-11e4-824f-806e6f6e6963}".length;
      var StorVolL = "STORAGE#Volume#".length;
      var w, p, q, r;

      w = VSLine.replace( /\\/g, "#" ); // this makes following analysis simpler

      if ( w.substr( 0, 4 ) == "##?#"
      ||   w.substr( 0, 4 ) == "_??_"
      ||   w.substr( 0, 4 ) == "#??#" )
      {
         w = w.substr( 4 );
      }

      // now w starts with : [ STORAGE, SD, USBSTOR, [ SCSI, IDE ] ]
      //

      /*
      -------------------------------------------------------------------------------------------------------------
      STORAGE\Volume\{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000000007E00
      STORAGE#Volume#{714ce426-d2a2-11e4-824f-806e6f6e6963}#0000000000007E00#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}

      STORAGE#Volume#_??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}

      USBSTOR#Disk&Ven_Multiple&Prod_Card__Reader&Rev_1.00#058F63666438&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      STORAGE\Volume\_??_USBSTOR#Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100#08AD000000002788&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}

      SCSI#CdRom&Ven_Msft&Prod_Virtual_DVD-ROM#2&1f4adffe&0&000001#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      -------------------------------------------------------------------------------------------------------------
      */
      // Case Partition :

      p = w.indexOf( "Volume#{" );

      if ( p > - 1 ) // this is Type = "Partition"
      {
         obj.DevID  = w.substr( StorVolL, GuidL );
         obj.Offset = w.substr( StorVolL + GuidL + 1, 16 ).toLowerCase();
         obj.Type   = "Partition";
         return obj;
      }

      // Case DVD - ROM :
      /*
      SCSI#CdRom&Ven_Msft&Prod_Virtual_DVD-ROM#2&1f4adffe&0&000003#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      SCSI#CdRom&Ven_MagicISO&Prod_Virtual_DVD-ROM&Rev_1.0A#1&2afd7d61&0&0000#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      SCSI#CdRom&Ven_MagicISO&Prod_Virtual_DVD-ROM&Rev_1.0A#1&2afd7d61&0&0000#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      IDE#CdRomATAPI_DVD_D__DH16D5SH___________________VA13____#5&830918e&0&1.0.0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      IDE#CdRomMATSHITA_DVD-R___UJ-8A8_________________HB14____#5&3363900d&0&1.0.0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#CdRom&Ven_Generic&Prod_Autorun_Disk&Rev_8.00#9A8EBA70&0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#CdRom&Ven_HL-DT-ST&Prod_DVDRAM_GP08NU20&Rev_1.01#001010164000810A5&0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#CdRom&Ven_HTC&Prod_Android_Phone&Rev_0000#HT2BPPG00552&2#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#CdRom&Ven_Lenovo&Prod_LePhone&Rev_0100#8&359c4e09&0&0123456789ABCDEF&2#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#CdRom&Ven_Motorola&Prod_Milestone_XT720&Rev_0001#040394FD1501C00B&0#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      ------------------------------ THIS - GUY - WILL - BE - IGNORED - HERE ---------------------------------------------------------------
      BUT it's GUID is: {53f56307-b6bf-11d0-94f2-00a0c91efb8b}" which means "GUID_DEVINTERFACE_DISK"
      USBSTOR#Disk&Ven_Linux&Prod_File-CD_Gadget&Rev_0000#8&2f9c7d9a&0&0123456789ABCDEF&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      */
      p = w.indexOf( "#CdRom" );
      q = w.indexOf( "#{"  );
      r = w.indexOf( "USBSTOR" );
      if ( p > - 1 )
      {
         obj.Type  = "DVD-ROM";
         obj.DevID = w.substr( 0, q );

         if ( r > - 1 )
         {
            obj.subtype = "USB";
         }
         else
         {
            obj.Subtype = w.indexOf( "Virtual" ) > - 1 ? "Virtual" : "Internal";
         }
         return obj;
      }

      // Case SD :
      p = w.indexOf( "SD#" );
      q = w.indexOf( "#{"  );

      /*
      STORAGE#Volume#_??_SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}#{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}
      SD#DISK&Generic&SA08G&0.4#6&447d92&0&9c053461&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Garmin&Prod_nuvi_SD_Card&Rev_1.00#0000e4ad13bd&1#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Generic&Prod_USB__SD_Reader&Rev_1.00#12345678901234567890&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Generic&Prod_MicroSD#M2&Rev_1.08#058F64656473&1#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Generic&Prod_SD#MMC#MS#xD&Rev_1.07#058F64656473&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Generic-&Prod_SD#MMC&Rev_1.00#20090815198100000&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Generic-&Prod_SD#MMC&Rev_1.00#20090815198100000&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      */

      if ( p > - 1 ) // this is SD
      {
         obj.Type = "Removable";
         obj.Subtype = "SD";
         obj.DevID = w.substr( 0, q ).substr( p );
         return obj;
      }

      // Case USBSTOR :
      p = w.indexOf( "USBSTOR#" );
      q = w.indexOf( "#{"  );
      /*
      USBSTOR#Disk&Ven_Multiple&Prod_Card__Reader&Rev_1.00#058F63666438&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      STORAGE#Volume#_??_USBSTOR#Disk&Ven_Generic&Prod_USB_Flash_Disk&Rev_1100#08AD000000002788&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_&Prod_USB_FLASH_DRIVE&Rev_PMAP#19870200036A&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_&Prod_USB_Flash_Memory&Rev_1.00#000AEB920172C9716375076F&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Flash&Prod_Drive_AU_USB20&Rev_8.07#7KHVK0K2&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_Garmin&Prod_nuvi_Flash&Rev_1.00#0000e4ad13bd&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_General&Prod_USB_Flash_Disk&Rev_1.0#03343000000051E6&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_USB&Prod_Flash_Disk&Rev_1.00#37B8A0CD02CAD3F1&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_USB&Prod_Flash_Disk&Rev_5.00#31213600628D1002&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_USB&Prod_USB_2.0_Flash&Rev_8.07#9E99283A&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_USB&Prod_USB_2.0_Flash&Rev_8.07#9E99283A&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_USB3.0&Prod_FlashDisk&Rev_1100#AA140401000000000023&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_HTC&Prod_Android_Phone&Rev_0000#8&2ebe8c83&0&HT23LV803484&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      USBSTOR#Disk&Ven_HTC&Prod_Android_Phone&Rev_0000#HT23LV803484&0#{53f56307-b6bf-11d0-94f2-00a0c91efb8b}
      */
      if ( p > - 1 ) // this is Removable
      {
         obj.Type = "Removable";
         obj.Subtype = "Flash";
         obj.DevID = w.substr( 0, q ).substr( p );
         return obj;
      }
      Out.StdErr.WriteLine( "LV parser Devid NOT Classified!!!" );
      return obj; // this couldn't happen !!!
   }  // End-of-SetObjectTypeByVolumeStorage

   ////////////////-Collection-Class-Function-ClassLV-////////////////////////////////////
   //                                                                                   //
   // Function is called from the function CollectionClass method Build                 //
   //                                                                                   //
   // Function loops by the items of the values read from the MountPoints2\CPC,         //
   // set many propertie on base of parsing binary blob Data                            //
   // to the target object which then is placed into the output array.                  //
   //                                                                                   //
   ///////////////////////////////////////////////////////////////////////////////////////
   // ------------------------------------------------------------------------
   // Function parses content of the MountPoints2 value name Data binary blob.
   //
   // Type names strictly corresponds to those used by Windows system utility
   // DISKPART.EXE which it uses in the answer to the "list volumes" command.
   //
   // 0 - VolumeGUID,          length = GuidL, present Registry key which value
   //                          with a name Data is the parsed to get following
   //                          properties :
   //
   // 1 - leading Blob part,   length depends on the Windows version
   // 2 - DevID,               length and content defines to which of the Sibling
   //     objects belong an object with this property
   // 3 - \\Volume\VolumeGUID, length = "\\\\Volume\\".length + GuidL
   //                          is not placed into the objects as it is function of
   //                          the already known VolumeGUID
   // 4 - Label,               Volume Label, length = 0x80
   // 5 - File System Name,    Volume File System name, length = 0x70
   // 6 - Driver Name,         Volume driver support name,
   //                          is absent for HDs as internal as USB
   // -------------------------------------------------------------------------

   function ClassLV( regObj, ShowKeys )                                                 // ClassLV - Starting -- tag
   {
      var StdReg  = regObj;
      var Assignments = [];

      var known = [
                     [ 0x0000, 4 ], //  1 half - word 2d02 or 0000
                     [ 0x0008, 8 ], //  2 full - word 00000000 or 0df0adba
                     [ 0x0010, 2 ], //* 3               - 41 - in DISKPART Info field, Boot
                     [ 0x0018, 2 ], //  4               - 08 -> HD, 04 -> flash / SD
                     [ 0x0026, 2 ], //  5 byte 08 or 04 - ?
                     [ 0x0036, 2 ], //  6 byte 08 or 04 - ?
                     [ 0x0048, 8 ], //  7 byte 08 or 04 - ?
                     [ 0x0050, 8 ], //  8 byte 08 or 04 - ?
                     [ 0x0058, 2 ], //* 9            - FS Type : 16 - NTFS, 10 - FAT32, BD - unknown
                     [ 0x0060, 8 ], //*                 - VolumeSerialNumber
                     [ 0x0068, 2 ], //* b byte 08 or 04 - 1e means SYSTEM in DISKPART Info field
                     [ 0x0070, 2 ]  //  c byte 84, 80, 85
      ];
      /*                                                                                  // ClassLV
      -------------------------------------------------------------------------------------------------------------
            ???? ???????? ** **                ???????  ** Serial#  ** ??
      -------------------------------------------------------------------  VolumeName___________ VolumeSerialNumber
            04   08       10 18 26 36 0x48     0x50     58 0x60     68 70
      156   0000 0df0adba 01 08 80 30 ff00e703 ff000000 16 aef012ac 1e 04  System Reserved
      156   d20d 00000000 01 10 80 30 05000801 6e000000 10 6670e021 00 00  Ptd                   21E07066
      156   0000 0df0adba 01 04 85 10 bdaddbba bdaddbba bd 00000000 1f 01
      156   d20d 00000000 01 08 80 30 ff00e703 ff000000 16 948b8032 1f 04  VhdP2Of4
      156   0000 0df0adba 01 08 80 30 ff00e703 ff000000 16 cd14ff0e 1f 04  Windows8.1-21-11-2014 0EFF14CD
      156   0000 0df0adba 41 08 80 30 ff00e703 ff000000 16 cd14ff0e 1f 04  WindowsTP             0EFF14CD
      156   0000 0df0adba 01 08 80 30 ff00e703 ff000000 16 26980b42 1f 04  LenovoReco            420B9826
      156   0000 0df0adba 01 08 84 30 ff00e703 ff000000 16 bf5d60d6 1f 04  TOSH-MK1646GSX        D6605DBF
      156   d20d 00000000 01 08 84 30 ff00e703 ff000000 16 d5083b58 1f 04  GPT5INCHP3            583B08D5
      156   d20d 00000000 01 08 80 30 ff00e703 ff000000 16 8e02b7b4 1f 04  VhdP3Of4              B4B7028E
      156   d20d 00000000 01 08 80 30 ff00e703 ff000000 16 09f3650c 1f 04  VhdP2Of2
      156   d20d 00000000 01 08 84 30 06000200 ff000000 10 86420330 1f 04  GPT5INCHP2
      156   d20d 00000000 01 08 80 30 ff00e703 ff000000 16 cf8461fe 1f 04  VhdP4Of4
      156   d20d 00000000 01 04 84 30 06000200 ff000000 10 9f0e9b20 1f 04  WORK                  209B0E9F
      156   0000 0df0adba 01 08 84 30 ff00e703 ff000000 16 7d293a10 1f 04  Windows7Enterprise    103A297D
      ---------------------------------------------------------------------------------------------------
      ....+....1....+....2....+....3....+....4....+....5....+....6....+.., S/N position in Unparsed = 54
      */

      // June 23 created, July 12, became function inside ClassLV                          // ClassLV
      // Function parses full DeviceId received from MountPoints2 blob or
      // from MountedDevices value and returns an array:
      //
      // 0 - Type:     { "Partition", "Removable", "DVD-ROM" }                             // ClassLV
      // 1 - Subtype:  { "Flash", "SD"          }
      // 2 - Short:    minimal significant DeviceId data to compare Devices
      //               IDs from different sources.
      // 3 - Offset, for Partition-type only
      //
      // P.A: MountedDevices can differ "Partition"-type items on base of                  // ClassLV
      // value length: length = 48 means Gpt-Style Partition-Type Volume
      //              for which Offset value can not be found among Volume data
      //               length = 24 means Mbr-Style Partition-Type Volume
      //               for which Parent-Disk Signature and Volume Offset values
      //               can be derived from the value.
      //

      /* Example output demonstrates data read from the MountedDevices                     // ClassLV
      ---------------------------------------------------------------------------------
      Windows Registry Editor Version 5.00
      [HKEY_LOCAL_MACHINE\SYSTEM\MountedDevices] - Windows 7 Enterprise
      "\\??\\Volume{e7a0f85f-f346-11e4-8309-806e6f6e6963}"=hex:c4c13610007e000000000000
      "\\??\\Volume{e7a0f860-f346-11e4-8309-806e6f6e6963}"=hex:c4c136100000261600000000
      "\\??\\Volume{e7a0f861-f346-11e4-8309-806e6f6e6963}"=hex:c4c1361000c0ce610f000000
      "\\??\\Volume{e7a0f862-f346-11e4-8309-806e6f6e6963}"=hex:c4c136100000907820000000
      "\\??\\Volume{e7a0f863-f346-11e4-8309-806e6f6e6963}"=hex:ef32a7ed0000100000000000
      "\\??\\Volume{e7a0f864-f346-11e4-8309-806e6f6e6963}"=hex:ef32a7ed00a0e5b71c000000
      "\\DosDevices\\C:"=hex:ef32a7ed00a0e5b71c000000
      "\\DosDevices\\E:"=hex:c4c136100000907820000000
      ---------------------------------------------------------------------------------
      */

      //                                                                                  // ClassLV
      // 1-st of the two functions in ClassLV which use StdRegClass ****
      // It Enums MountPoints2\CPC, takes last item of the full
      // path as a VolumeGUID and then read and parse binary blob Data
      // which permits to create a LogicalVolume object with a lot of
      // properties.
      //
      // Function returns an array :                                                      // ClassLV
      //
      // VolumeGUID
      // tmp[ 0 ] - unparsed leading part of the blob
      // tmp[ 1 ] - device id ( text string which is parsed to detect and
      //            set device properties
      // tmp[ 2 ] - \\Volume\VolumeGUID
      // tmp[ 3 ] - Volume Label,      may be empty for encrypted
      // tmp[ 4 ] - Volume FileSystem, may be empty for encrypted
      // tmp[ 5 ] - driver data, empty for Partition - Type volumes
      // Some additional object properties are set later on base
      // of the unparsed part properties.
      //
      function GetBlobs()                                                                  // ClassLV
      {
         String.prototype.StripTrailingZ = function()
         {
            return this.replace( /(0*)$/, "" );
         }
         String.prototype.StripBlobTail = function()
         {
            var t = this.split( "ffffffffffffffffffffffffffffffffffffffff" );
            if ( t.length == 2 ) return t[ 0 ].StripTrailingZ();
            t = this.split( "ffffffffffffffff00000000ffffffff" );
            return t[ 0 ].StripTrailingZ();
            // + "0000" + t[ 1 ].substr( 8 );
         }
         String.prototype.StripVolumes = function()                                         // ClassLV
         {
            var Prefix = "5c005c003f005c00";
            var LVolL  = "Volume{3c0003d5-d08a-45da-8165-7af3134976c4}\\".length;
            var LabelL = 0x80;                                        // 128 hex chars = 64 binary bytes
            var FSL    = 0x70;                                        //
            var ret = [];
            var tmp = this.split( Prefix );                           // contains leading hex data, vol1, vol2, Ctrl                                  // ClassLV
            ret[ 0 ] = tmp[ 0 ];                                      // save leading data

            ret[ 1 ] = ( Prefix + tmp[ 1 ] ).HexString2ASCI();        // save vol1 : dev

            ret[ 2 ] = ( Prefix + tmp[ 2 ].substr( 0, 4 * ( LVolL ) ) ).HexString2ASCI();  // save vol1 : vol

            tmp = tmp[ 2 ].substr( 4 * ( LVolL + 1 ) );               // contains Label, FS, Ctrl
            ret[ 3 ] = tmp.substr( 0, LabelL ).HexString2ASCI();      // save Label : lab

            tmp = tmp.substr( LabelL + 4 );                           // contains FS, Ctrl
            ret[ 4 ] = tmp.substr( 0, FSL ).HexString2ASCI();         // save FS : fs
            tmp = tmp.substr( FSL + 4 );
            ret[ 5 ] = tmp.substr( 0 ).HexString2ASCI();              // contains Driver data

            return ret;
         }  // End-of-String.prototype.StripVolumes                                            // ClassLV

         var SID = CurrentUserSID;            // is set by the StdRegWrapperClass constructor

         var key = SID + "\\Software\\Microsoft\\Windows\\CurrentVersion" +
         "\\Explorer\\MountPoints2\\CPC\\Volume";

         var HKU = 0x80000003;               // HKEY_USERS

         var Vols = StdReg.RegEnumKey( HKU, key );  // enum all volumes in CPC ***

         var ret = [], path;                        // subkeys received presents VolumeGUID

         if ( Vols == null || Vols.length == 0 ) return ret;                                   // ClassLV

         for ( var i = 0; i < Vols.length; i ++ )
         {
            path = key + "\\" + Vols[ i ];
            ret[ ret.length ] = [
            Vols[ i ],
            StdReg.RegGetBinaryValue( HKU, path , "Data" ).StripBlobTail() ];  // ***
         }

         return ret;
      }  // End-of-GetBlobs()

      function GetKnown( blob )
      {
         if ( typeof( blob ) != "string" )                                                       // ClassLV
         {
            Out.StdErr.WriteLine( "*** GetKnown typeof( blob ) = " + typeof( blob ) );
            return "";
         }
         var ret = blob.length.toString().left( 4 ) + " ", tmp;
         for ( var i = 0; i < known.length; i ++ )
         {
            tmp = known[ i ];
            ret += blob.substr( tmp[ 0 ], tmp[ 1 ] ) + " ";
         }
         return ret;                                                                               // ClassLV
      }

      function FormatAssignMsg( Letter, index, Type, Detail )
      {
         var msg = Letter + " assigned at index " + index.toString().right(2) + " to " +
         Type.left( "Mbr partition".length + 1 ) + Detail;
         Assignments[ Assignments.length ] = msg;
         return false;
      }

      function setStyle( obj )                                                                        // ClassLV
      {
         if ( obj.Type != "Partition" )
         {
            if ( obj.Type == "DVD-ROM" )
            {
               obj.Offset = "";                                                                        // ClassLV
            }
            else
            {
               obj.Offset = "0000000000000000";
            }
         }
         if ( obj.Type != "DVD-ROM" )
         {
            var pobj = DevicesCollection[ obj.ParentIndex ];

            if ( pobj.Type == "HD" && pobj.Subtype == "Internal" )
            {
               obj.Style = pobj.LVGroupStyle;
            }

            pobj.LVGroup += pobj.LVGroup == "" ? obj.Offset : "," + obj.Offset;                      // ClassLV
            pobj.NumberOfLV++;
            DevicesCollection[ obj.ParentIndex ] = pobj;
         }
         return obj;
      }

      //
      // CollectLogicalVolumes execution starts                                                     // ClassLV
      //

      var DEBUG = false;

      this.Count = 0;

      var blob, msg, Unparsed;
      var GuidL    = "{714ce426-d2a2-11e4-824f-806e6f6e6963}".length;
      var Blobs    = GetBlobs();
      // collect all data from MountPoints2\CPC

      var obj, tmp, devid, offset, ParentType, index;                                               // ClassLV

      var ChildN    = 1;
      var PrevDCUniqueID = "";
      var IsOffset  = false;

      var TColl = {};  // temporary collection for SV - objects
      var Count = 0;   // number of the objects placed into the temporary collection

      for ( var i = 0; i < Blobs.length; i ++ )
      {
         obj = {};
         blob = Blobs[ i ][ 1 ];                                                                      // ClassLV
      // Unparsed = GetKnown( blob ); // this is necessary for printing table shown above
         tmp  = blob.StripVolumes();           // parse Blob content
         blob = tmp[ 0 ];
         // this is an unparsed leading part of the Blob Data which contains :
         // + 10, 2 - 41 means that volume is Bootable ( corresponds to an Active partition )
         // + 18, 2 - 10 Type : 10 -> DVD - ROM, 04 -> Removable, 08 -> HD
         // + 60, 8 - Serial Number
         // + 68, 2 - 1e means Partition is System, that is presents running Windows system

         obj  = SetObjectTypeByVolumeStorageString( obj, tmp[ 1 ] );                                  // ClassLV

         if ( obj.DevID.charAt( 0 ) == "{" )
         {
            obj.DevID = obj.DevID.substr( 1, 8 );                                                     // ClassLV
         }

         index = DevicesCollection[ obj.DevID ];

         if ( typeof( index ) != "number" )
         {
            InternalError( obj, "LV" );
         }

         obj.ParentIndex = index;
         obj.DCUniqueID  = DevicesCollection[ index ].DCUniqueID;                                      // ClassLV
         obj.VolumeGUID = Blobs[ i ][0];  // property : VolumeGUID == MountPoint

         obj.Label      = tmp[ 3 ];       // DiskPart use Label, Win32_LogicalDisk use "VolumeName" instead of Label
         obj.Fs         = tmp[ 4 ];       // DiskPart use Fs,    Win32_LogicalDisk use "FileSystem"
         obj.VolumeSN   = blob.substr( 0x60, 8 ).invertHexString().toUpperCase(); // DiskPart says nothing
         obj.Boot       = ( blob.substr( 0x10, 2 ) == "41" );    // DiskPart use it in Info field
         obj.System     = ( blob.substr( 0x68, 2 ) == "1e" );    // DiskPart use it in Info field
         obj.UserName   = CurrentUserObject.CurrentUserName;     // and THIS data IS NOT set by Win32_LogicalDisk
         obj.Style      = "";                                    // initialize as Unknown

		   pobj           = DevicesCollection[ index ];
         obj = setStyle( obj ); // July 30
         if ( pobj.Type == "HD" )                                                                       // ClassLV
		   {
		      obj.Type    = "Partition";
			   obj.Subtype = pobj.Subtype;
			   obj.LVUniqueID = pobj.DCUniqueID + obj.Offset;                                              // ClassLV
         }
         else// Removable or DVD-ROM come here. Offset is not applicable to DVD-ROM                                                                                        // ClassLV
		   {//    but we already set Offset="" for DVD-ROMs and thus no more IF's :)
		      obj.Subtype = pobj.Subtype;
		      obj.LVUniqueID = pobj.DCUniqueID + obj.Offset;                                              // ClassLV
         }

         // we should control and correctly set ChildNumber property
         // Small fragment which follow provides correct ChildNumber
         // property assignment

         if ( obj.DCUniqueID != PrevDCUniqueID )                                                             // ClassLV
         {
            if ( PrevDCUniqueID != "" )
            {
               ChildN = DevicesCollection[ obj.ParentIndex ].NumberOfLV;
               if ( obj.Type == "Partition" ) ++ChildN;
            }
            PrevDCUniqueID = obj.DCUniqueID;                                                             // ClassLV
         }
         obj.ChildNumber = ChildN;

         // that is all, just place an object prepared into the temporary collection                     // ClassLV

         if ( typeof( TColl[ obj.ParentIndex ] ) == "undefined" )
         {
            TColl[ obj.ParentIndex ] = [];                                                               // ClassLV
         }

 //        obj = setStyle( obj );

         TColl[ obj.ParentIndex ][ TColl[ obj.ParentIndex ].length ] = obj;
         ++Count;     // increment number of the LV objects collected
      } // End-of-Collecting-Objects-loop

      var nc, pobj, f1;
      var nd = DevicesCollection.Count;

      for ( var i = 0; i < nd; i ++ )                                                                      // ClassLV
      {
         nc = TColl[ i ].length;
         pobj = DevicesCollection[ i ];

         // July 27, very STRANGE decesion to sort CPC\Volume by VolumeGUIDS resulted
         // that the childs of the one parent are not immedeatly following each other
         // as it always be sence at least Build 7601. This decesion looks like sorting
         // childs nor by the the same parent and Offset but by the height.
         // Thus we HAD TO SORT LVGroup as a childs with SMALL offsets may follow childs            // ClassLV
         // with a BIG Offsets. NE BOGI GORSHKI OBJIGAYUT in MS !!!
         // WHAT FOR it was necessary to SORT CPC\Volume by VolumeGUIDs ????
         // It would be absolutly CORRECT decesion provided an ordering of the Volumes
         // was the same as used by DISKPART.EXE. Though an order of the Volumes in
         // CPC\Volume is NATURAL, corresponding to the 1-st appearence of each of the
         // Volume in the system.
         //

         if ( pobj.NumberOfSV == pobj.NumberOfLV )                                                   // ClassLV
         {
            pobj.LVGroupStyle = "Mbr";
            if ( pobj.NumberOfSV > 1  // sorting of the LVGroup is necessary since Build 10240
            &&  CurrentVersionObject.CurrentBuild >= 10240 )
            {
               pobj.LVGroup = pobj.SVGroup; //// NO NEED SORTING, just copy SVGroup //// July 28
            }
         }
         else if ( pobj.Type == "HD" )//&& pobj.LVGroupStyle == "" )
         {
            pobj.LVGroupStyle = "Gpt";                                                               // ClassLV
         }

         for( var j = 0; j < nc; j ++ )
         {
            obj = TColl[ i ][ j ];
            if(DEBUG)WScript.StdOut.WriteLine( i.toString().right(2)+" "+j.toString().right(2)+
            " "+obj.Type+" "+obj.Subtype+" "+
             pobj.Type+" "+pobj.Subtype+" "+pobj.LVGroupStyle );
            if ( obj.Style == "" )
            {
               obj.Style = pobj.LVGroupStyle;                                                           // ClassLV
            }

            if ( obj.Type != "Partition" )
            {
               this[ obj.DevID ] = this.Count;
               if(DEBUG)WScript.StdOut.WriteLine( i.toString().right(2)+" "+j.toString().right(2)+
               " "+this.Count.toString().right(2)+" new key "+obj.DevID );

            }

            //  0123456789a                                                                              // ClassLV
            //  {1036c1c4-0000-0000-007e-000000000000}
            if ( obj.Style == "Mbr" )
            {
               if (0)//( CurrentVersionObject.CurrentBuild > 7601 )// even under 10240 works for a 2-nd disk
               {
                  obj.SignOwner = false;
                  if ( obj.VolumeGUID.substr( 10, 9 ) == "0000-0000" ) // This case happens at Windows 8.1+
                  {                                                    // This feature permits to decrease
                     f1 = obj.VolumeGUID.substr( 1, 8 ) + obj.Offset;  // number of unnecessary VolumesGuid.field 1
                     obj.SignOwner = true;                             // keys created in LogicalVolumes collection:
                     this[ f1 ] = this.Count;                          // only SignOwners keys are tecessary and
                  }                                                    // will be matched by MountedDevices Sign keys
               }
               else if ( obj.Type == "Partition" )                     // For Mbr-Style Volumes all VolumeGUID.field 1
               {                                                       // keys had to be created which will be matched
                  f1 = obj.VolumeGUID.substr( 1, 8 ) + obj.Offset;     // by the MountedDevices DosDevices as only
                  this[ f1 ] = this.Count;                             // Gpts with MountNames assigned are present
                  if(DEBUG)WScript.StdOut.WriteLine( i.toString().right(2)+" "+j.toString().right(2)+
                  " "+this.Count.toString().right(2)+" new key "+f1 );
               }// End-of-Else                                                       // in MountedDevices
            }// End-of-if ( obj.Style == "Mbr" )
            else if ( obj.Style == "Gpt" && obj.Type == "Partition" )
            {
               this[ obj.VolumeGUID.substr( 1, 8 ) ] = this.Count;
               if(DEBUG)WScript.StdOut.WriteLine( i.toString().right(2)+" "+j.toString().right(2)+
               " "+this.Count.toString().right(2)+" new key "+obj.VolumeGUID.substr( 1, 8 ) );
            }

            obj.OrderIndex = this.Count;                                                                    // ClassLV
            this[ this.Count ] = obj;
            ++this.Count;
         }//  End-of-J-loop

      }// End-of-I-Loop                                                                                     // ClassLV

      var HKLM = 0x80000002;// HKEY_LOCAL_MACHINE

      var tmp = regObj.RegGetAllValues( HKLM, "SYSTEM\\MountedDevices" ); // ***       // ClassLV

      // Array tmp contains objects each of which has only two properties:
      // name and value. Additional properties are name.length and value.length.
      // Here we will set to the objects following properties derived from the
      // name and value properties.
      //
      // Properties derived from the object tmp[i].name:
      // name, VolumeGUID ( new name property will replace original one )
      //
      // Properties derived from the object tmp[i].value:                                // ClassLV
      // Unique, Style, Type
      //
      // Property derived from the tmp[i].value provided
      // tmp[ i ].value.length == 48:
      // VolumeGUID derived from the tmp[ i ].value                                      // ClassLV
      //

      var cVolume     = "\\??\\Volume";   //
      var cDosDevices = "\\DosDevices\\"; //
      var rc, count;
      var Unique, index, key, msg;
      Out.StdOut.WriteLine( "\n" );
	   var guids = [], letters = [];
      for ( var i = 0; i < tmp.length; i++ )
      {
         if ( tmp[ i ].name.charAt( 0 ) == "#" ) continue; // ignore junk entries        // ClassLV
         delete tmp[ i ].type;

		   if ( tmp[ i ].name.charAt( 1 ) == "?" ) // Volume
		   {
		      guids[ guids.length ] = tmp[ i ];
		   }
		   else
		   {
		      letters[ letters.length ] = tmp[ i ];
		   }
      }

      tmp = [];
	  for ( var i = 0; i < guids.length; i++ )                                             // ClassLV
	  {
	     tmp[ tmp.length ] = guids[ i ];
	  }
	  delete guids;
	  for ( var i = 0; i < letters.length; i++ )
	  {
	     tmp[ tmp.length ] = letters[ i ];
	  }
	  delete letters;

      for ( var i = 0; i < tmp.length; i++ )
      {
         //
         // set properties derived from the name value: Letter, VolumeGUID, name         // ClassLV
         //
         tmp[ i ].Letter = tmp[ i ].name.startsWith( cVolume ) ? " " :
         tmp[ i ].name.substr( cDosDevices.length, 1 );

         if ( tmp[ i ].Letter == " " )
         {
            tmp[ i ].VolumeGUID = tmp[ i ].name.substr( cVolume.length, GuidL );
         }

         //
         // set properties derived from the value length: Type, Style, Unique             // ClassLV
         //

         if ( tmp[ i ].value.length > 48 ) // Type = Removable OR DVD
         {
            tmp[ i ] = SetObjectTypeByVolumeStorageString( tmp[ i ], tmp[ i ].value.HexString2ASCI() );

            index = this[ tmp[ i ].DevID ];                      // EXCLUDE REMOVABLES and DVDs
                                                                 // WHICH ARE ABSENT
            if ( typeof( index ) != "number" ) continue;         // IN DevicesCollection           // ClassLV

            tmp[ i ].Type = this[ index ].Type;                  // set correct object Type value

            if ( tmp[ i ].Letter == " " ) continue;              //
            this[ index ].Letter = tmp[ i ].Letter;
            FormatAssignMsg( this[ index ].Letter, index, this[ index ].Type, this[ index ].DevID );
            continue;

         } // End-of-case-value.length > 48                                                        // ClassLV

         if ( tmp[ i ].value.length == 48  )
         {
            Unique = tmp[ i ].value.substr( 16 ).ConvertQWORD().buildGuid().substr( 1, 8 ); // Gpt VolumeGUID Field 1

            index = this[ Unique ];                                 // EXCLUDE Gpts
                                                                    // WHICH are absent
            if ( typeof( index ) != "number" ) continue;            // in LogicalVolumesCollection

            this[ index ].Letter = tmp[ i ].Letter;

            FormatAssignMsg( this[ index ].Letter, index, "Gpt Partition", Unique );
            continue;
         }

         if ( tmp[ i ].value.length == 24 )                                                 // ClassLV
         {
            tmp[ i ].Type  = "Partition"
            tmp[ i ].Style = "Mbr";

            if ( tmp[ i ].Letter == " " )// that id VolumeGUID is defined
            {
               Unique = tmp[ i ].VolumeGUID.substr( 1, 8 ) +          // GUID Field 1            // ClassLV
                        tmp[ i ].value.substr( 8 ).invertHexString(); // Offset

               index = this[ Unique ];

               if ( typeof( index ) == "number" )
               {
                  if(DEBUG)WScript.StdOut.WriteLine( "Mbr key "+Unique+" gives index "+index );
                  this[ index ].Letter = " ";
                  msg = tmp[ i ].Letter + " assigned Mbr " + Unique + " Signature " + tmp[ i ].value.substr( 0, 8 );
                  //
                  // CREATE one more key on base of Signature                                   // ClassLV
                  //
                  Unique = tmp[ i ].value.substr( 0, 8 ) +
                  tmp[ i ].value.substr( 8 ).invertHexString();
                  this[ Unique ] = index;
                  msg += ", new Direct Access key: " + Unique;
                  Assignments[ Assignments.length ] = msg;
                  continue;
               }
            }
            else // Letter is assigned, can use only Signature
            {
               Unique = tmp[ i ].value.substr( 0, 8 ) + // Signature
                        tmp[ i ].value.substr( 8 ).invertHexString();     // Offset

               index = this[ Unique ];                                    // EXCLUDE Mbrts        // ClassLV
                                                                          // WHICH are absent
               if ( typeof( index ) == "number" )
               {
                  this[ index ].Letter = tmp[ i ].Letter;
                  if ( tmp[ i ].Letter == " " ) continue;//
                  FormatAssignMsg( this[ index ].Letter, index, "Mbr Partition",
                  Unique + " Signature " + tmp[ i ].value.substr( 0, 8 ) );
                  continue;
               }
            }
         }

      } // End-of-i-loop                                                                   // ClassLV
      Out.StdOut.WriteLine( "\n" );

      this.Show = function()                                                                                // ClassLV
      {                                                                                                     // ClassLV
         var cnt = this.Count;                                                                              // ClassLV
         Out.StdOut.WriteLine( "\n" );                                                                      // ClassLV
         Out.StdOut.WriteLine( "There are " + cnt + " objects in LogicalVolumesCollection" );               // ClassLV
         Out.StdOut.WriteLine( "\n" );                                                                      // ClassLV
         for( var i = 0; i < cnt; i++ )                                                                     // ClassLV
         {                                                                                                  // ClassLV
            ShowObject( this[ i ] );                                                                        // ClassLV
         }
         Out.StdOut.WriteLine( "Following MountPoints and MountNames were matched" );                         // ClassLV
         Out.StdOut.WriteLine( "\n" );                                                                      // ClassLV
         for( var i = 0; i < Assignments.length; i++ )                                                                     // ClassLV
         {
            if ( i > 0
            && Assignments[ i - 1 ].charAt(0) == " "
            && Assignments[ i ].charAt(0) != " " )
            {
               Out.StdOut.WriteLine( "\n" );
            }                                                                                                  // ClassLV
            Out.StdOut.WriteLine( Assignments[ i ] );                                                                        // ClassLV
         }
         Out.StdOut.WriteLine( "\n" );                                                                      // ClassLV                                                                                                 // ClassLV
         return false;                                                                                      // ClassLV
      }
      /*
      VN  Ltr  Label        S/N       FS     Type       Subtype  Gpt  VolGUID.F1  DevGUID.F1  Offset
      --  ---  -----------  --------  -----  ---------  -------  ---  ----------  ----------  ----------------
       0   G   Ptd          21E07066  CDFS   DVD-ROM    Virtual       dd798685
       1   J   J_CCSA_X64F  DE4864B7  UDF    DVD-ROM    Virtual       dd798689
       2       System Rese  AC12F0AE  NTFS   Partition                2c654a1d    714ce426    0000000000007e00
       3   C   Windows8.1-  0EFF14CD  NTFS   Partition                714ce430    714ce426    0000000016260000
       4   D   WindowsTP    0EFF14CD  NTFS   Partition                714ce431    714ce426    0000000f61cec000
       5   E   LenovoReco   420B9826  NTFS   Partition                714ce432    714ce426    0000002078900000
       6   F   TOSH-MK1646  D6605DBF  NTFS   Partition                714ce433    714ce427    0000000000100000
       7   S   Windows7Ent  103A297D  NTFS   Partition                ffbc9827    714ce427    0000001cb7e5a000
       8   A                00000000         Removable  SD            714ce42e                0000000000000000
       9   I   WORK         F60E5F71  exFAT  Removable  Flash         83983fcd                0000000000000000
      10       VhdP2Of4     32808B94  NTFS   Partition            *   3c0003d5    714ce438    0000000002010000
      11   H   VhdP3Of4     B4B7028E  NTFS   Partition            *   a1aeb03a    714ce438    000000000e810000
      12       VhdP4Of4     FE6184CF  NTFS   Partition            *   d62e2174    714ce438    0000000018e10000
      13       VhdP2Of2     0C65F309  NTFS   Partition            *   b903be82    120e7228    0000000002010000
      14   K   GPT5INCHP3   583B08D5  NTFS   Partition            *   92ca44de    13f29a4f    0000000088100000
      15       GPT5INCHP2   30034286  FAT32  Partition            *   cd0164ca    13f29a4f    0000000008100000
      */
      this.BriefShow = function()
      {
         var GuidL = "{cd0164ca-8336-423e-82f4-5e6f37a87aee}".length;
         var out1 = "", out2 = "", rule, blanks, fieldl, fieldn;
         var HDArr = [
         [ "VN",          "OrderIndex",  "2,L" ],
         [ "Ltr",         "Letter",      "3,L" ],
         [ "Label",       "Label",      "11,l" ],
         [ "S/N",         "VolumeSN",    "8,n" ],
         [ "FS",          "Fs",          "5,l" ],
         [ "Type",        "Type",        "9,l" ],
         [ "Subtype",     "Subtype",     "8,L" ],
         [ "Gpt",         "Style",       "3,L" ],
         [ "VolGUID.F1",  "VolumeGUID",  "10,L" ],
         [ "DevGUID.F1",  "DevID",       "10,L" ],
         [ "Offset",      "Offset",      "16,L" ]
                   ];

         function BuildOut( obj )
         {
            out1   = "";
            for ( var i = 0; i < HDArr.length; i++ )
            {
               rule   = HDArr[ i ][ 2 ].split( "," );
               fieldn = HDArr[ i ][ 1 ]; // name of the object property
               fieldl = rule[ 0 ];       // output lenght of the property presentation
               switch( rule[ 1 ] )
               {
                  case "l": out1 += obj[ fieldn ].left(  fieldl ) + "  "; break;
                  case "r": out1 += obj[ fieldn ].right( fieldl ) + "  "; break;
                  case "n": out1 += obj[ fieldn ] + "  "; break;
                  case "L":
                  {
                     if ( fieldn == "OrderIndex" )
                     {
                        out1 += obj.OrderIndex.toString().right( fieldl ) + "  ";
                        break;
                     }
                     if ( fieldn == "Letter" )
                     {
                        out1 += ( typeof( obj.Letter ) == "undefined" ? " " : " " + obj.Letter ).left( fieldl ) + "  ";
                        break;
                     }
                     if ( fieldn == "Subtype" )
                     {
                        out1 += ( typeof( obj.Subtype ) == "undefined" ? " " : obj.Subtype ).left( fieldl ) + "  ";
                        break;
                     }
                     if ( fieldn == "Style" )
                     {
                        out1 += ( obj.Style == "Gpt" ? " *" : " " ).left( fieldl ) + "  ";
                        break;
                     }
                     if ( fieldn == "DevID" )
                     {
                        out1 += ( obj.Type != "DVD-ROM" ? obj.DCUniqueID : " " ).left( fieldl ) + "  ";
                        break;
                     }
                     if ( fieldn == "VolumeGUID" )
                     {
                        out1 += ( obj.VolumeGUID.substr( 1, 8 ) ).left( fieldl  ) + "  ";
                        break;
                     }
                     if ( fieldn == "Offset" )
                     {
                        out1 += obj.Offset.left( fieldl ) + " ";
                        break;
                     }
                  }
               }
            }
            return out1;
         } // End-of-function-BuildOut

         for ( var i = 0; i < HDArr.length; i++ )
         {
            rule   = HDArr[ i ][ 2 ].split( "," );
            fleng  = rule[ 0 ];
            out1 += HDArr[ i ][ 0 ].left( fleng ) + "  ";
            out2 += "-".repeat( fleng ) + "  ";
         }

         Out.StdOut.WriteLine( out1 );
         Out.StdOut.WriteLine( out2 );

         var cnt = this.Count;

         for ( var i = 0; i < cnt; i++ )
         {
            Out.StdOut.WriteLine( BuildOut( this[ i ] ) );
         }
         Out.StdOut.WriteLine( "\n\n" );
         return false;
      }  // End-of-function-BriefShow
      this.ShowCollectionKeys = function()
      {
         Out.StdOut.WriteLine( "\n" );
         Out.StdOut.WriteLine( "Direct Access Keys in LogicalVolumesCollection" );
         for( var p in this )
         {
            if( typeof( this[ p ] ) == "number" )
            {
              Out.StdOut.WriteLine( this[ p ] + " " + p );
            }
         }
         Out.StdOut.WriteLine( "\n" );
         return true;
      }//
   }  // End-of-ClassLV function                                                                    // ClassLV-Trailing-Tag


   //////////////////////////////-CollectionClassConstructor-////////////////////       // CollectionClassConstructor
   //                                                                          //       // CollectionClassConstructor
   // CollectionClassConstructor Code Starts                                   //       // CollectionClassConstructor
   //                                                                          //       // CollectionClassConstructor
   //////////////////////////////////////////////////////////////////////////////       // CollectionClassConstructor

   var GuidL = "{714ce430-d2a2-11e4-824f-806e6f6e6963}".length;
   var GuidsLeft = "38 714ce4380000000018e10000 SVUnique     10".length;
   var ContainerLeft = "ContainerID-f1  ".length;

   var ShowKeys = true; // must be set by the run method !!!!!!!!!!!!

   this.Run = function()                                                                // CollectionClassRun method
   {                                                                                    // CollectionClassRun method
      DevicesCollection        = new ClassDC( StdRegInstance );                         // CollectionClassRun method
      StorageVolumesCollection = new ClassSV( StdRegInstance );                         // CollectionClassRun method
      LogicalVolumesCollection = new ClassLV( StdRegInstance );                         // CollectionClassRun method
   }                                                                                    // CollectionClassRun method

   this.ShowResemblanse = function()// July 12                                          // CollectionClassConstructor
   {                                                                                    // CollectionClass ShowResemblanse
      var cnt, obj, msg;
      var Uniques = [];                                                                 // CollectionClass ShowResemblanse
      cnt = DevicesCollection.Count;
      for ( var i = 0; i < cnt; i++ )                                                   // CollectionClass ShowResemblanse
      {
         obj = DevicesCollection[ i ];
         msg = obj.DCUniqueID.substr( 6, 2 ) + " "  + obj.DCUniqueID.left( 24 ) + " DCUnique     " +
               obj.OrderIndex.toString().right( 2 ) + " OrderIndex ".left( ContainerLeft ) +  (obj.Type).left(9) + " DC";
         msg += " " + obj.LVGroupStyle;
         Uniques[ Uniques.length ] = msg;
      }                                                                                 // CollectionClass ShowResemblanse
      cnt = StorageVolumesCollection.Count;                                             // CollectionClass ShowResemblanse
      for ( var i = 0; i < cnt; i++ )
      {
         obj = StorageVolumesCollection[ i ];
         msg = obj.SVUniqueID.substr( 6, 2 ) + " "  + obj.SVUniqueID.left( 24 ) + " SVUnique     " +
               obj.OrderIndex.toString().right( 2 ) + " OrderIndex ".left( ContainerLeft ) + (obj.Type).left(9) + " SV";
         Uniques[ Uniques.length ] = msg;
         if ( StorageVolumesCollection[ i ].ContainerID.substr( 1, 8 ) != "00000000" )
         {
            msg = ( obj.ContainerID.substr( 7, 2 ) + " " + obj.ContainerID.substr( 1, 8 ) ).left( GuidsLeft ) +
            " ContainerID-f1".left( ContainerLeft ) + obj.Type.left(9) + " SV";
            msg += " " + DevicesCollection[ obj.ParentIndex ].LVGroupStyle;
            Uniques[ Uniques.length ] = msg;                                             // CollectionClass ShowResemblanse
         }
      }
      cnt = LogicalVolumesCollection.Count;
      for ( var i = 0; i < cnt; i++ )                                                    // CollectionClass ShowResemblanse
      {
         obj = LogicalVolumesCollection[ i ];
         msg = obj.LVUniqueID.substr( 6, 2 ) + " "  + obj.LVUniqueID.left( 24 ) + " LVUnique     " +
               obj.OrderIndex.toString().right( 2 ) + " OrderIndex ".left( ContainerLeft ) + (obj.Type).left(9) + " LV";
         Uniques[ Uniques.length ] = msg;
         msg = ( obj.VolumeGUID.substr( 7, 2 ) + " " + obj.VolumeGUID.substr( 1, 8 ) ).left( GuidsLeft ) +
         " VolumeGUID-f1".left( ContainerLeft ) + obj.Type.left(9) + " LV";
         msg += " " + obj.Style;
         Uniques[ Uniques.length ] = msg;                                               // CollectionClass ShowResemblanse
      }
      Uniques.sort();
      Out.StdOut.WriteLine( "\n" );
      Out.StdOut.WriteLine( "--- All-Collections-Objects-Resemblence-Demo ---" );       // CollectionClass ShowResemblanse
      Out.StdOut.WriteLine( "\n" );
      cnt = Uniques.length;
      for ( var i = 0; i < cnt; i++ )
      {
         Out.StdOut.WriteLine( Uniques[ i ] );                                          // CollectionClass ShowResemblanse
      }
      Out.StdOut.WriteLine( "\n" );
      return false;                                                                     // CollectionClassConstructor
   }                                                                                    // CollectionClassConstructor
   this.Show = function()// June 27                                                     // CollectionClassConstructor
   {                                                                                    // CollectionClassConstructor
      DevicesCollection.Show();                                                         // CollectionClassConstructor
      StorageVolumesCollection.Show();                                                  // CollectionClassConstructor
      LogicalVolumesCollection.Show();                                                  // CollectionClassConstructor
      LogicalVolumesCollection.BriefShow();
      LogicalVolumesCollection.ShowCollectionKeys();
      this.ShowResemblanse();                                                           // CollectionClassConstructor
      return false;                                                                     // CollectionClassConstructor
   }                                                                                    // CollectionClassConstructor                                                                                  // CollectionClass prepareDPInput

} // End-of-CollectionClass                                                             // CollectionClassConstructor-Trailing-Tag
</script>                    <!-- CollectionClass TrailingTag -->
<script language="JScript">//<!-- TestCase-EnumDevicesAndVolumes LeadingTag -->
//===========================================================================
// Test code for StdRegWrapperClass, EnumDevicesVolumesClass
//===========================================================================
var MyName = WScript.ScriptName;
var fso    = new ActiveXObject( "Scripting.FileSystemObject" );
var path   = fso.GetAbsolutePathName( "." );
var CreateLogFiles = false;
var UseStorageBuffers = false;
var Out  = {};
Out.StdErr  = WScript.StdErr;
Out.StdOut  = WScript.StdOut;
var regObj  = null;
var now     = null;
var tobj    = null;
var started = null;
var gb      = null;

var rver, dver;

var IsCompetition;
try
{
   IsCompetition = ( WScript.Arguments.Item(0).toLowerCase() == "compete" );
}
catch(e)
{
   IsCompetition = false;
   CreateLogFiles = true;
   UseStorageBuffers = true;
   now     = new Date();
   started = now.getTime();
}

var tClass  = "EnumDevicesVolumesClass";
var Version = "1.02 build 01 July 29";

function CountDuration( started )
{
   var finished, duration, durmilli, durss, durmm, durhh, cdur;
   var second   = 1000;
   var minute   = second * 60;

   finished = new Date().getTime();
   duration = finished - started;
   cdur = duration + " milliseconds";

   if ( duration > second )
   {
      durss = Math.round( duration / second );
      durmilli = ( duration + 999 ) % second;
      cdur = "Processor time used: "+durss + "." + durmilli + " seconds";
   }
   return cdur;
}

regObj = new StdRegWrapperClass();     // create an instance of the StdRegWrapperClass
regObj.SetWarnings( 0 );               // enable warnings
rver = regObj.GetVersion();            // get version of StdRegWrapperClass
regObj.SetUseCallCounts( 1 );          // enable counting of the calls

tobj = new CollectionClass( regObj );  // create an instance of the CollectionClass
dver = tobj.GetVersion();              // get version of CollectionClass

if ( IsCompetition )
{
   Out.StdOut.WriteLine( "\n" );
   Out.StdOut.WriteLine( "Build "+CurrentVersionObject.CurrentBuild+
                           ", StdRegWrapperClass version " + rver +
                           ", EnumDevicesAndVolumesClass version " + dver );
   Out.StdOut.WriteLine( "\n" );
}
else
{
   gb = new GlobalBuffers();              // create GlobalBuffers instance
   gb.Out.StdErr = Out.StdErr;            // redefine Output for the GlobalBuffers
   gb.Out.StdOut = Out.StdOut;            // redefine Output for the GlobalBuffers

   regObj.OutBuffers = gb;
   regObj.Out.StdErr = gb.PutEMsg;        // redefine Output for the StdRegWrapperClass
   regObj.Out.StdOut = gb.PutIMsg;        // redefine Output for the StdRegWrapperClass

   tobj.OutBuffers = gb;
   tobj.Out.StdErr = gb.PutEMsg;          // redefine Output for the CollectionClass
   tobj.Out.StdOut = gb.PutIMsg;          // redefine Output for the CollectionClass

   gb.PutIMsg( "\n" );
   gb.PutIMsg( "Build "+CurrentVersionObject.CurrentBuild+
               ", StdRegWrapperClass version " + rver +
               ", EnumDevicesAndVolumesClass version " + dver );
   gb.PutIMsg( "\n" );
}

tobj.Run();

if ( ! IsCompetition )
{
   cdur = CountDuration( started );
   gb.PutIMsg( MyName + " finished building collections at " + now.toString() );
   gb.PutIMsg( cdur );

   var OutLog = MyName + "-" + CurrentVersionObject.CurrentBuild + "-StdOut.txt";
   var ErrLog = MyName + "-" + CurrentVersionObject.CurrentBuild + "-StdErr.txt";

   Out.StdErr = fso.CreateTextFile( OutLog, true, 0 );// overwrite, ascii
   Out.StdOut = fso.CreateTextFile( ErrLog, true, 0 );// overwrite, ascii
   gb.Out.StdErr = Out.StdErr;
   gb.Out.StdOut = Out.StdOut;
   gb.UnloadBuffers();
   tobj.Out.StdErr = Out.StdErr;          // redefine Output for the EnumDevicesPartionsVolumesClass
   tobj.Out.StdOut = Out.StdOut;          // redefine Output for the EnumDevicesPartionsVolumesClass
}

tobj.Show();                              // Output report

var Counts = regObj.GetCallCounts();

for ( var p in Counts )
{
   if ( ! Counts[ p ] ) continue;
   Out.StdOut.WriteLine( "StdRegWrapperClass method " + p.left( "RegGetMultiStringValue ".length + 1 ) +
   " was used " + Counts[ p ].toString().right( 3, " " ) + " times" );
}

if ( IsCompetition )
{
   var fn = path + "\\DP_Input.txt";
   var fh = fso.CreateTextFile( fn, true, 0 );// overwrite, ascii
   fh.WriteLine( "list disk" );
   for ( var i = 0; i < DevicesCollection.Count; i++ )
   {
      fh.WriteLine( "select disk " + i );
      fh.WriteLine( "detail disk " );
      fh.WriteLine( "list part" );
      /*
      for ( var j = 0; j < DevicesCollection[ i ].NumberOfSV; j++ )
      {
         fh.WriteLine( "select part " + j );
         fh.WriteLine( "detail part" );
      }
      */
   }
   fh.WriteLine( "list disk" );
   for ( var i = 0; i < LogicalVolumesCollection.Count; i++ )
   {
      fh.WriteLine( "select volume " + i );
      fh.WriteLine( "detail volume" );
   }
   fh.WriteLine( "exit" );
   fh.close();
   fh = null;
}
if ( fso != null )
{
   Out.StdErr.close();
   Out.StdOut.close();
}
WScript.Quit();
</script>//<!-- TestCase-EnumDevicesAndVolumes TrailingTag -->
</job>
<!----End-of-File-EnumDevicesAndVolumes.wsf--------------------------------->
